{
  "address": "0xa4f9b98c1Bce4b0A9Bbe5dcBf17dc64a55C79477",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_divider",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_target",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_underlying",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "oracle",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "stake",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "stakeSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minm",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxm",
              "type": "uint256"
            },
            {
              "internalType": "uint64",
              "name": "tilt",
              "type": "uint64"
            },
            {
              "internalType": "uint48",
              "name": "level",
              "type": "uint48"
            },
            {
              "internalType": "uint16",
              "name": "mode",
              "type": "uint16"
            }
          ],
          "internalType": "struct BaseAdapter.AdapterParams",
          "name": "_adapterParams",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "FlashCallbackFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyPeriphery",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TokenNotSupported",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "trusted",
          "type": "bool"
        }
      ],
      "name": "UserTrustUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CALLBACK_SUCCESS",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "adapterParams",
      "outputs": [
        {
          "internalType": "address",
          "name": "oracle",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "stake",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "stakeSize",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minm",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxm",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "tilt",
          "type": "uint64"
        },
        {
          "internalType": "uint48",
          "name": "level",
          "type": "uint48"
        },
        {
          "internalType": "uint16",
          "name": "mode",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "divider",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "flashFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC3156FlashBorrower",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "flashLoan",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getMaturityBounds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getStakeAndTarget",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getUnderlyingPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ifee",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "isTrusted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "level",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "maxFlashLoan",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mode",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "name": "notify",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "onRedeem",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "openSponsorWindow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "scale",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "scaleStored",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_scale",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "trusted",
          "type": "bool"
        }
      ],
      "name": "setIsTrusted",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_scale",
          "type": "uint256"
        }
      ],
      "name": "setScale",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "target",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tilt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "underlying",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tBal",
          "type": "uint256"
        }
      ],
      "name": "unwrapTarget",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "uBal",
          "type": "uint256"
        }
      ],
      "name": "wrapUnderlying",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xa0534108a4cb8c4bef49f659e87911df1353da174822f91c5eb47311acbccb48",
  "receipt": {
    "to": null,
    "from": "0xF13519734649F7464E5BE4aa91987A35594b2B16",
    "contractAddress": "0xa4f9b98c1Bce4b0A9Bbe5dcBf17dc64a55C79477",
    "transactionIndex": 105,
    "gasUsed": "1589275",
    "logsBloom": "0x00000000000000010000000000000000000000000000012000000000000000000000000000000000000000000000000080000000000000000004000002200000000000000000002000000000020000000020000000000100000400000000000000000000000000000000000000000000000000000100000000080000000000000000000800000000080000000000000000000000000000000000000000000000020000000000000000000000000000000001000000008000000000000000000000000000000000000000400000000000000000000000000000000000000000000010000000000000000000000000000000000000000220000008000000000000",
    "blockHash": "0xc91f83573ee50e7182c9a0564386bfec249dad94d6185fc1b8c01894027373e3",
    "transactionHash": "0xa0534108a4cb8c4bef49f659e87911df1353da174822f91c5eb47311acbccb48",
    "logs": [
      {
        "transactionIndex": 105,
        "blockNumber": 8078912,
        "transactionHash": "0xa0534108a4cb8c4bef49f659e87911df1353da174822f91c5eb47311acbccb48",
        "address": "0xF3A0C5F5Ae311e824DeFDcf9DaDFBd6a7a404DB8",
        "topics": [
          "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925",
          "0x000000000000000000000000a4f9b98c1bce4b0a9bbe5dcbf17dc64a55c79477",
          "0x00000000000000000000000009b10e45a912bcd4e80a8a3119f0cfccad1e1f12"
        ],
        "data": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "logIndex": 188,
        "blockHash": "0xc91f83573ee50e7182c9a0564386bfec249dad94d6185fc1b8c01894027373e3"
      },
      {
        "transactionIndex": 105,
        "blockNumber": 8078912,
        "transactionHash": "0xa0534108a4cb8c4bef49f659e87911df1353da174822f91c5eb47311acbccb48",
        "address": "0xC027849ac78202A17A872021Bd0271DA5df04168",
        "topics": [
          "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925",
          "0x000000000000000000000000a4f9b98c1bce4b0a9bbe5dcbf17dc64a55c79477",
          "0x00000000000000000000000009b10e45a912bcd4e80a8a3119f0cfccad1e1f12"
        ],
        "data": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "logIndex": 189,
        "blockHash": "0xc91f83573ee50e7182c9a0564386bfec249dad94d6185fc1b8c01894027373e3"
      },
      {
        "transactionIndex": 105,
        "blockNumber": 8078912,
        "transactionHash": "0xa0534108a4cb8c4bef49f659e87911df1353da174822f91c5eb47311acbccb48",
        "address": "0xa4f9b98c1Bce4b0A9Bbe5dcBf17dc64a55C79477",
        "topics": [
          "0xe95aec380cae16330d146d5499ef7db6f3657e477104a733e771bc09e500d986",
          "0x000000000000000000000000f13519734649f7464e5be4aa91987a35594b2b16"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 190,
        "blockHash": "0xc91f83573ee50e7182c9a0564386bfec249dad94d6185fc1b8c01894027373e3"
      }
    ],
    "blockNumber": 8078912,
    "cumulativeGasUsed": "18629458",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x09B10E45A912BcD4E80a8A3119f0cfCcad1e1f12",
    "0xF3A0C5F5Ae311e824DeFDcf9DaDFBd6a7a404DB8",
    "0xB209E94E9216331af1158E8588dD69e0a88eA2Da",
    [
      "0x0000000000000000000000000000000000000000",
      "0xC027849ac78202A17A872021Bd0271DA5df04168",
      "250000000000000000",
      0,
      "315576000",
      0,
      31,
      0
    ]
  ],
  "numDeployments": 3,
  "solcInputHash": "277be13b5f131878be1d8e94788c0d35",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_divider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stake\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxm\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"tilt\",\"type\":\"uint64\"},{\"internalType\":\"uint48\",\"name\":\"level\",\"type\":\"uint48\"},{\"internalType\":\"uint16\",\"name\":\"mode\",\"type\":\"uint16\"}],\"internalType\":\"struct BaseAdapter.AdapterParams\",\"name\":\"_adapterParams\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FlashCallbackFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPeriphery\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotSupported\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"trusted\",\"type\":\"bool\"}],\"name\":\"UserTrustUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CALLBACK_SUCCESS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adapterParams\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stake\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxm\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"tilt\",\"type\":\"uint64\"},{\"internalType\":\"uint48\",\"name\":\"level\",\"type\":\"uint48\"},{\"internalType\":\"uint16\",\"name\":\"mode\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"divider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"flashFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC3156FlashBorrower\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaturityBounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeAndTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ifee\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTrusted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"level\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"maxFlashLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"notify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"onRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openSponsorWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaleStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"trusted\",\"type\":\"bool\"}],\"name\":\"setIsTrusted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"name\":\"setScale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tilt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tBal\",\"type\":\"uint256\"}],\"name\":\"unwrapTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uBal\",\"type\":\"uint256\"}],\"name\":\"wrapUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"flashLoan(address,address,uint256,bytes)\":{\"params\":{\"amount\":\"The amount of target lent.\",\"data\":\"(encoded adapter address, maturity and YT amount the use has sent in)\",\"receiver\":\"The contract receiving target, needs to implement the `onFlashLoan(address user, address adapter, uint256 maturity, uint256 amount)` interface.\"}},\"maxFlashLoan(address)\":{\"details\":\"The amount of currency available to be lent.\",\"params\":{\"token\":\"The loan currency.\"},\"returns\":{\"_0\":\"The amount of `token` that can be borrowed.\"}},\"scaleStored()\":{\"details\":\"For situations where you need scale from a view function\"}},\"stateVariables\":{\"scale\":{\"details\":\"For some Targets, such as cTokens, this is simply the exchange rate, or `supply cToken / supply underlying`For other Targets, such as AMM LP shares, specialized logic will be requiredThis function _must_ return a WAD number representing the current exchange rate between the Target and the Underlying.\",\"return\":\"value WAD Scale value\",\"returns\":{\"_0\":\"value WAD Scale value\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"adapterParams()\":{\"notice\":\"adapter params\"},\"divider()\":{\"notice\":\"Sense core Divider address\"},\"flashLoan(address,address,uint256,bytes)\":{\"notice\":\"Loan `amount` target to `receiver`, and takes it back after the callback.\"},\"getUnderlyingPrice()\":{\"notice\":\"Returns the current price of the underlying in ETH terms\"},\"ifee()\":{\"notice\":\"Issuance fee\"},\"notify(address,uint256,bool)\":{\"notice\":\"Notification whenever the Divider adds or removes Target\"},\"onRedeem(uint256,uint256,uint256,uint256)\":{\"notice\":\"Hook called whenever a user redeems PT\"},\"scale()\":{\"notice\":\"Calculate and return this adapter's Scale value for the current timestamp. To be overriden by child contracts\"},\"scaleStored()\":{\"notice\":\"Cached scale value getter\"},\"target()\":{\"notice\":\"Target token to divide\"},\"underlying()\":{\"notice\":\"Underlying for the Target\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/auto-roller/src/test/utils/MockOwnedAdapter.sol\":\"MockOwnableAdapter\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363730323430373738333034\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":500},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/security/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0x0849d93b16c9940beb286a7864ed02724b248b93e0d80ef6355af5ef15c64773\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@sense-finance/v1-core/src/Divider.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\n// External references\\nimport { Pausable } from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\nimport { SafeTransferLib } from \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\nimport { ReentrancyGuard } from \\\"solmate/src/utils/ReentrancyGuard.sol\\\";\\nimport { DateTime } from \\\"./external/DateTime.sol\\\";\\nimport { FixedMath } from \\\"./external/FixedMath.sol\\\";\\n\\n// Internal references\\nimport { Errors } from \\\"@sense-finance/v1-utils/src/libs/Errors.sol\\\";\\n\\nimport { Levels } from \\\"@sense-finance/v1-utils/src/libs/Levels.sol\\\";\\nimport { Trust } from \\\"@sense-finance/v1-utils/src/Trust.sol\\\";\\nimport { YT } from \\\"./tokens/YT.sol\\\";\\nimport { Token } from \\\"./tokens/Token.sol\\\";\\nimport { BaseAdapter as Adapter } from \\\"./adapters/abstract/BaseAdapter.sol\\\";\\n\\n/// @title Sense Divider: Divide Assets in Two\\n/// @author fedealconada + jparklev\\n/// @notice You can use this contract to issue, combine, and redeem Sense ERC20 Principal and Yield Tokens\\ncontract Divider is Trust, ReentrancyGuard, Pausable {\\n    using SafeTransferLib for ERC20;\\n    using FixedMath for uint256;\\n    using Levels for uint256;\\n\\n    /* ========== PUBLIC CONSTANTS ========== */\\n\\n    /// @notice Buffer before and after the actual maturity in which only the sponsor can settle the Series\\n    uint256 public constant SPONSOR_WINDOW = 3 hours;\\n\\n    /// @notice Buffer after the sponsor window in which anyone can settle the Series\\n    uint256 public constant SETTLEMENT_WINDOW = 3 hours;\\n\\n    /// @notice 5% issuance fee cap\\n    uint256 public constant ISSUANCE_FEE_CAP = 0.05e18;\\n\\n    /* ========== PUBLIC MUTABLE STORAGE ========== */\\n\\n    address public periphery;\\n\\n    /// @notice Sense community multisig\\n    address public immutable cup;\\n\\n    /// @notice Principal/Yield tokens deployer\\n    address public immutable tokenHandler;\\n\\n    /// @notice Permissionless flag\\n    bool public permissionless;\\n\\n    /// @notice Guarded launch flag\\n    bool public guarded = true;\\n\\n    /// @notice Number of adapters (including turned off)\\n    uint248 public adapterCounter;\\n\\n    /// @notice adapter ID -> adapter address\\n    mapping(uint256 => address) public adapterAddresses;\\n\\n    /// @notice adapter data\\n    mapping(address => AdapterMeta) public adapterMeta;\\n\\n    /// @notice adapter -> maturity -> Series\\n    mapping(address => mapping(uint256 => Series)) public series;\\n\\n    /// @notice adapter -> maturity -> user -> lscale (last scale)\\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public lscales;\\n\\n    /* ========== DATA STRUCTURES ========== */\\n\\n    struct Series {\\n        // Principal ERC20 token\\n        address pt;\\n        // Timestamp of series initialization\\n        uint48 issuance;\\n        // Yield ERC20 token\\n        address yt;\\n        // % of underlying principal initially reserved for Yield\\n        uint96 tilt;\\n        // Actor who initialized the Series\\n        address sponsor;\\n        // Tracks fees due to the series' settler\\n        uint256 reward;\\n        // Scale at issuance\\n        uint256 iscale;\\n        // Scale at maturity\\n        uint256 mscale;\\n        // Max scale value from this series' lifetime\\n        uint256 maxscale;\\n    }\\n\\n    struct AdapterMeta {\\n        // Adapter ID\\n        uint248 id;\\n        // Adapter enabled/disabled\\n        bool enabled;\\n        // Max amount of Target allowed to be issued\\n        uint256 guard;\\n        // Adapter level\\n        uint248 level;\\n    }\\n\\n    constructor(address _cup, address _tokenHandler) Trust(msg.sender) {\\n        cup = _cup;\\n        tokenHandler = _tokenHandler;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /// @notice Enable an adapter\\n    /// @dev when permissionless is disabled, only the Periphery can onboard adapters\\n    /// @dev after permissionless is enabled, anyone can onboard adapters\\n    /// @param adapter Adapter's address\\n    function addAdapter(address adapter) external whenNotPaused {\\n        if (!permissionless && msg.sender != periphery) revert Errors.OnlyPermissionless();\\n        if (adapterMeta[adapter].id > 0 && !adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\\n        _setAdapter(adapter, true);\\n    }\\n\\n    /// @notice Initializes a new Series\\n    /// @dev Deploys two ERC20 contracts, one for PTs and the other one for YTs\\n    /// @dev Transfers some fixed amount of stake asset to this contract\\n    /// @param adapter Adapter to associate with the Series\\n    /// @param maturity Maturity date for the new Series, in units of unix time\\n    /// @param sponsor Sponsor of the Series that puts up a token stake and receives the issuance fees\\n    function initSeries(\\n        address adapter,\\n        uint256 maturity,\\n        address sponsor\\n    ) external nonReentrant whenNotPaused returns (address pt, address yt) {\\n        if (periphery != msg.sender) revert Errors.OnlyPeriphery();\\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\\n        if (_exists(adapter, maturity)) revert Errors.DuplicateSeries();\\n        if (!_isValid(adapter, maturity)) revert Errors.InvalidMaturity();\\n\\n        // Transfer stake asset stake from caller to adapter\\n        (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\\n\\n        // Deploy Principal & Yield Tokens for this new Series\\n        (pt, yt) = TokenHandler(tokenHandler).deploy(adapter, adapterMeta[adapter].id, maturity);\\n\\n        // Initialize the new Series struct\\n        uint256 scale = Adapter(adapter).scale();\\n\\n        series[adapter][maturity].pt = pt;\\n        series[adapter][maturity].issuance = uint48(block.timestamp);\\n        series[adapter][maturity].yt = yt;\\n        series[adapter][maturity].tilt = uint96(Adapter(adapter).tilt());\\n        series[adapter][maturity].sponsor = sponsor;\\n        series[adapter][maturity].iscale = scale;\\n        series[adapter][maturity].maxscale = scale;\\n\\n        ERC20(stake).safeTransferFrom(msg.sender, adapter, stakeSize);\\n\\n        emit SeriesInitialized(adapter, maturity, pt, yt, sponsor, target);\\n    }\\n\\n    /// @notice Settles a Series and transfers the settlement reward to the caller\\n    /// @dev The Series' sponsor has a grace period where only they can settle the Series\\n    /// @dev After that, the reward becomes MEV\\n    /// @param adapter Adapter to associate with the Series\\n    /// @param maturity Maturity date for the new Series\\n    function settleSeries(address adapter, uint256 maturity) external nonReentrant whenNotPaused {\\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\\n        if (_settled(adapter, maturity)) revert Errors.AlreadySettled();\\n        if (!_canBeSettled(adapter, maturity)) revert Errors.OutOfWindowBoundaries();\\n\\n        // The maturity scale value is all a Series needs for us to consider it \\\"settled\\\"\\n        uint256 mscale = Adapter(adapter).scale();\\n        series[adapter][maturity].mscale = mscale;\\n\\n        if (mscale > series[adapter][maturity].maxscale) {\\n            series[adapter][maturity].maxscale = mscale;\\n        }\\n\\n        // Reward the caller for doing the work of settling the Series at around the correct time\\n        (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\\n        ERC20(target).safeTransferFrom(adapter, msg.sender, series[adapter][maturity].reward);\\n        ERC20(stake).safeTransferFrom(adapter, msg.sender, stakeSize);\\n\\n        emit SeriesSettled(adapter, maturity, msg.sender);\\n    }\\n\\n    /// @notice Mint Principal & Yield Tokens of a specific Series\\n    /// @param adapter Adapter address for the Series\\n    /// @param maturity Maturity date for the Series [unix time]\\n    /// @param tBal Balance of Target to deposit\\n    /// @dev The balance of PTs and YTs minted will be the same value in units of underlying (less fees)\\n    function issue(\\n        address adapter,\\n        uint256 maturity,\\n        uint256 tBal\\n    ) external nonReentrant whenNotPaused returns (uint256 uBal) {\\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\\n        if (_settled(adapter, maturity)) revert Errors.IssueOnSettle();\\n\\n        uint256 level = adapterMeta[adapter].level;\\n        if (level.issueRestricted() && msg.sender != adapter) revert Errors.IssuanceRestricted();\\n\\n        ERC20 target = ERC20(Adapter(adapter).target());\\n\\n        // Take the issuance fee out of the deposited Target, and put it towards the settlement reward\\n        uint256 issuanceFee = Adapter(adapter).ifee();\\n        if (issuanceFee > ISSUANCE_FEE_CAP) revert Errors.IssuanceFeeCapExceeded();\\n        uint256 fee = tBal.fmul(issuanceFee);\\n\\n        unchecked {\\n            // Safety: bounded by the Target's total token supply\\n            series[adapter][maturity].reward += fee;\\n        }\\n        uint256 tBalSubFee = tBal - fee;\\n\\n        // Ensure the caller won't hit the issuance cap with this action\\n        unchecked {\\n            // Safety: bounded by the Target's total token supply\\n            if (guarded && target.balanceOf(adapter) + tBal > adapterMeta[address(adapter)].guard)\\n                revert Errors.GuardCapReached();\\n        }\\n\\n        // Update values on adapter\\n        Adapter(adapter).notify(msg.sender, tBalSubFee, true);\\n\\n        uint256 scale = level.collectDisabled() ? series[adapter][maturity].iscale : Adapter(adapter).scale();\\n\\n        // Determine the amount of Underlying equal to the Target being sent in (the principal)\\n        uBal = tBalSubFee.fmul(scale);\\n\\n        // If the caller has not collected on YT before, use the current scale, otherwise\\n        // use the harmonic mean of the last and the current scale value\\n        lscales[adapter][maturity][msg.sender] = lscales[adapter][maturity][msg.sender] == 0\\n            ? scale\\n            : _reweightLScale(\\n                adapter,\\n                maturity,\\n                YT(series[adapter][maturity].yt).balanceOf(msg.sender),\\n                uBal,\\n                msg.sender,\\n                scale\\n            );\\n\\n        // Mint equal amounts of PT and YT\\n        Token(series[adapter][maturity].pt).mint(msg.sender, uBal);\\n        YT(series[adapter][maturity].yt).mint(msg.sender, uBal);\\n\\n        target.safeTransferFrom(msg.sender, adapter, tBal);\\n\\n        emit Issued(adapter, maturity, uBal, msg.sender);\\n    }\\n\\n    /// @notice Reconstitute Target by burning PT and YT\\n    /// @dev Explicitly burns YTs before maturity, and implicitly does it at/after maturity through `_collect()`\\n    /// @param adapter Adapter address for the Series\\n    /// @param maturity Maturity date for the Series\\n    /// @param uBal Balance of PT and YT to burn\\n    function combine(\\n        address adapter,\\n        uint256 maturity,\\n        uint256 uBal\\n    ) external nonReentrant whenNotPaused returns (uint256 tBal) {\\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\\n\\n        uint256 level = adapterMeta[adapter].level;\\n        if (level.combineRestricted() && msg.sender != adapter) revert Errors.CombineRestricted();\\n\\n        // Burn the PT\\n        Token(series[adapter][maturity].pt).burn(msg.sender, uBal);\\n\\n        // Collect whatever excess is due\\n        uint256 collected = _collect(msg.sender, adapter, maturity, uBal, uBal, address(0));\\n\\n        uint256 cscale = series[adapter][maturity].mscale;\\n        bool settled = _settled(adapter, maturity);\\n        if (!settled) {\\n            // If it's not settled, then YT won't be burned automatically in `_collect()`\\n            YT(series[adapter][maturity].yt).burn(msg.sender, uBal);\\n            // If collect has been restricted, use the initial scale, otherwise use the current scale\\n            cscale = level.collectDisabled()\\n                ? series[adapter][maturity].iscale\\n                : lscales[adapter][maturity][msg.sender];\\n        }\\n\\n        // Convert from units of Underlying to units of Target\\n        tBal = uBal.fdiv(cscale);\\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, msg.sender, tBal);\\n\\n        // Notify only when Series is not settled as when it is, the _collect() call above would trigger a _redeemYT which will call notify\\n        if (!settled) Adapter(adapter).notify(msg.sender, tBal, false);\\n        unchecked {\\n            // Safety: bounded by the Target's total token supply\\n            tBal += collected;\\n        }\\n        emit Combined(adapter, maturity, tBal, msg.sender);\\n    }\\n\\n    /// @notice Burn PT of a Series once it's been settled\\n    /// @dev The balance of redeemable Target is a function of the change in Scale\\n    /// @param adapter Adapter address for the Series\\n    /// @param maturity Maturity date for the Series\\n    /// @param uBal Amount of PT to burn, which should be equivalent to the amount of Underlying owed to the caller\\n    function redeem(\\n        address adapter,\\n        uint256 maturity,\\n        uint256 uBal\\n    ) external nonReentrant whenNotPaused returns (uint256 tBal) {\\n        // If a Series is settled, we know that it must have existed as well, so that check is unnecessary\\n        if (!_settled(adapter, maturity)) revert Errors.NotSettled();\\n\\n        uint256 level = adapterMeta[adapter].level;\\n        if (level.redeemRestricted() && msg.sender != adapter) revert Errors.RedeemRestricted();\\n\\n        // Burn the caller's PT\\n        Token(series[adapter][maturity].pt).burn(msg.sender, uBal);\\n\\n        // Principal Token holder's share of the principal = (1 - part of the principal that belongs to Yield)\\n        uint256 zShare = FixedMath.WAD - series[adapter][maturity].tilt;\\n\\n        // If Principal Token are at a loss and Yield have some principal to help cover the shortfall,\\n        // take what we can from Yield Token's principal\\n        if (series[adapter][maturity].mscale.fdiv(series[adapter][maturity].maxscale) >= zShare) {\\n            tBal = (uBal * zShare) / series[adapter][maturity].mscale;\\n        } else {\\n            tBal = uBal.fdiv(series[adapter][maturity].maxscale);\\n        }\\n\\n        if (!level.redeemHookDisabled()) {\\n            Adapter(adapter).onRedeem(uBal, series[adapter][maturity].mscale, series[adapter][maturity].maxscale, tBal);\\n        }\\n\\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, msg.sender, tBal);\\n        emit PTRedeemed(adapter, maturity, tBal);\\n    }\\n\\n    function collect(\\n        address usr,\\n        address adapter,\\n        uint256 maturity,\\n        uint256 uBalTransfer,\\n        address to\\n    ) external nonReentrant onlyYT(adapter, maturity) whenNotPaused returns (uint256 collected) {\\n        uint256 uBal = YT(msg.sender).balanceOf(usr);\\n        return _collect(usr, adapter, maturity, uBal, uBalTransfer > 0 ? uBalTransfer : uBal, to);\\n    }\\n\\n    /// @notice Collect YT excess before, at, or after maturity\\n    /// @dev If `to` is set, we copy the lscale value from usr to this address\\n    /// @param usr User who's collecting for their YTs\\n    /// @param adapter Adapter address for the Series\\n    /// @param maturity Maturity date for the Series\\n    /// @param uBal yield Token balance\\n    /// @param uBalTransfer original transfer value\\n    /// @param to address to set the lscale value from usr\\n    function _collect(\\n        address usr,\\n        address adapter,\\n        uint256 maturity,\\n        uint256 uBal,\\n        uint256 uBalTransfer,\\n        address to\\n    ) internal returns (uint256 collected) {\\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\\n\\n        // If the adapter is disabled, its Yield Token can only collect\\n        // if associated Series has been settled, which implies that an admin\\n        // has backfilled it\\n        if (!adapterMeta[adapter].enabled && !_settled(adapter, maturity)) revert Errors.InvalidAdapter();\\n\\n        Series memory _series = series[adapter][maturity];\\n\\n        // Get the scale value from the last time this holder collected (default to maturity)\\n        uint256 lscale = lscales[adapter][maturity][usr];\\n\\n        uint256 level = adapterMeta[adapter].level;\\n        if (level.collectDisabled()) {\\n            // If this Series has been settled, we ensure everyone's YT will\\n            // collect yield accrued since issuance\\n            if (_settled(adapter, maturity)) {\\n                lscale = series[adapter][maturity].iscale;\\n                // If the Series is not settled, we ensure no collections can happen\\n            } else {\\n                return 0;\\n            }\\n        }\\n\\n        // If the Series has been settled, this should be their last collect, so redeem the user's Yield Tokens for them\\n        if (_settled(adapter, maturity)) {\\n            _redeemYT(usr, adapter, maturity, uBal);\\n        } else {\\n            // If we're not settled and we're past maturity + the sponsor window,\\n            // anyone can settle this Series so revert until someone does\\n            if (block.timestamp > maturity + SPONSOR_WINDOW) {\\n                revert Errors.CollectNotSettled();\\n                // Otherwise, this is a valid pre-settlement collect and we need to determine the scale value\\n            } else {\\n                uint256 cscale = Adapter(adapter).scale();\\n                // If this is larger than the largest scale we've seen for this Series, use it\\n                if (cscale > _series.maxscale) {\\n                    _series.maxscale = cscale;\\n                    lscales[adapter][maturity][usr] = cscale;\\n                    // If not, use the previously noted max scale value\\n                } else {\\n                    lscales[adapter][maturity][usr] = _series.maxscale;\\n                }\\n            }\\n        }\\n\\n        // Determine how much underlying has accrued since the last time this user collected, in units of Target.\\n        // (Or take the last time as issuance if they haven't yet)\\n        //\\n        // Reminder: `Underlying / Scale = Target`\\n        // So the following equation is saying, for some amount of Underlying `u`:\\n        // \\\"Balance of Target that equaled `u` at the last collection _minus_ Target that equals `u` now\\\"\\n        //\\n        // Because maxscale must be increasing, the Target balance needed to equal `u` decreases, and that \\\"excess\\\"\\n        // is what Yield holders are collecting\\n        uint256 tBalNow = uBal.fdivUp(_series.maxscale); // preventive round-up towards the protocol\\n        uint256 tBalPrev = uBal.fdiv(lscale);\\n        unchecked {\\n            collected = tBalPrev > tBalNow ? tBalPrev - tBalNow : 0;\\n        }\\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, usr, collected);\\n        Adapter(adapter).notify(usr, collected, false); // Distribute reward tokens\\n\\n        // If this collect is a part of a token transfer to another address, set the receiver's\\n        // last collection to a synthetic scale weighted based on the scale on their last collect,\\n        // the time elapsed, and the current scale\\n        if (to != address(0)) {\\n            uint256 ytBal = YT(_series.yt).balanceOf(to);\\n            // If receiver holds yields, we set lscale to a computed \\\"synthetic\\\" lscales value that,\\n            // for the updated yield balance, still assigns the correct amount of yield.\\n            lscales[adapter][maturity][to] = ytBal > 0\\n                ? _reweightLScale(adapter, maturity, ytBal, uBalTransfer, to, _series.maxscale)\\n                : _series.maxscale;\\n            uint256 tBalTransfer = uBalTransfer.fdiv(_series.maxscale);\\n            Adapter(adapter).notify(usr, tBalTransfer, false);\\n            Adapter(adapter).notify(to, tBalTransfer, true);\\n        }\\n        series[adapter][maturity] = _series;\\n\\n        emit Collected(adapter, maturity, collected);\\n    }\\n\\n    /// @notice calculate the harmonic mean of the current scale and the last scale,\\n    /// weighted by amounts associated with each\\n    function _reweightLScale(\\n        address adapter,\\n        uint256 maturity,\\n        uint256 ytBal,\\n        uint256 uBal,\\n        address receiver,\\n        uint256 scale\\n    ) internal view returns (uint256) {\\n        // Target Decimals * 18 Decimals [from fdiv] / (Target Decimals * 18 Decimals [from fdiv] / 18 Decimals)\\n        // = 18 Decimals, which is the standard for scale values\\n        return (ytBal + uBal).fdiv((ytBal.fdiv(lscales[adapter][maturity][receiver]) + uBal.fdiv(scale)));\\n    }\\n\\n    function _redeemYT(\\n        address usr,\\n        address adapter,\\n        uint256 maturity,\\n        uint256 uBal\\n    ) internal {\\n        // Burn the users's YTs\\n        YT(series[adapter][maturity].yt).burn(usr, uBal);\\n\\n        // Default principal for a YT\\n        uint256 tBal = 0;\\n\\n        // Principal Token holder's share of the principal = (1 - part of the principal that belongs to Yield Tokens)\\n        uint256 zShare = FixedMath.WAD - series[adapter][maturity].tilt;\\n\\n        // If PTs are at a loss and YTs had their principal cut to help cover the shortfall,\\n        // calculate how much YTs have left\\n        if (series[adapter][maturity].mscale.fdiv(series[adapter][maturity].maxscale) >= zShare) {\\n            tBal = uBal.fdiv(series[adapter][maturity].maxscale) - (uBal * zShare) / series[adapter][maturity].mscale;\\n            ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, usr, tBal);\\n        }\\n\\n        // Always notify the Adapter of the full Target balance that will no longer\\n        // have its rewards distributed\\n        Adapter(adapter).notify(usr, uBal.fdivUp(series[adapter][maturity].maxscale), false);\\n\\n        emit YTRedeemed(adapter, maturity, tBal);\\n    }\\n\\n    /* ========== ADMIN ========== */\\n\\n    /// @notice Enable or disable a adapter\\n    /// @param adapter Adapter's address\\n    /// @param isOn Flag setting this adapter to enabled or disabled\\n    function setAdapter(address adapter, bool isOn) public requiresTrust {\\n        _setAdapter(adapter, isOn);\\n    }\\n\\n    /// @notice Set adapter's guard\\n    /// @param adapter Adapter address\\n    /// @param cap The max target that can be deposited on the Adapter\\n    function setGuard(address adapter, uint256 cap) external requiresTrust {\\n        adapterMeta[adapter].guard = cap;\\n        emit GuardChanged(adapter, cap);\\n    }\\n\\n    /// @notice Set guarded mode\\n    /// @param _guarded bool\\n    function setGuarded(bool _guarded) external requiresTrust {\\n        guarded = _guarded;\\n        emit GuardedChanged(_guarded);\\n    }\\n\\n    /// @notice Set periphery's contract\\n    /// @param _periphery Target address\\n    function setPeriphery(address _periphery) external requiresTrust {\\n        periphery = _periphery;\\n        emit PeripheryChanged(_periphery);\\n    }\\n\\n    /// @notice Set paused flag\\n    /// @param _paused boolean\\n    function setPaused(bool _paused) external requiresTrust {\\n        _paused ? _pause() : _unpause();\\n    }\\n\\n    /// @notice Set permissioless mode\\n    /// @param _permissionless bool\\n    function setPermissionless(bool _permissionless) external requiresTrust {\\n        permissionless = _permissionless;\\n        emit PermissionlessChanged(_permissionless);\\n    }\\n\\n    /// @notice Backfill a Series' Scale value at maturity if keepers failed to settle it\\n    /// @param adapter Adapter's address\\n    /// @param maturity Maturity date for the Series\\n    /// @param mscale Value to set as the Series' Scale value at maturity\\n    /// @param _usrs Values to set on lscales mapping\\n    /// @param _lscales Values to set on lscales mapping\\n    function backfillScale(\\n        address adapter,\\n        uint256 maturity,\\n        uint256 mscale,\\n        address[] calldata _usrs,\\n        uint256[] calldata _lscales\\n    ) external requiresTrust {\\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\\n\\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\\n        // Admin can never backfill before maturity\\n        if (block.timestamp <= cutoff) revert Errors.OutOfWindowBoundaries();\\n\\n        // Set user's last scale values the Series (needed for the `collect` method)\\n        for (uint256 i = 0; i < _usrs.length; i++) {\\n            lscales[adapter][maturity][_usrs[i]] = _lscales[i];\\n        }\\n\\n        if (mscale > 0) {\\n            Series memory _series = series[adapter][maturity];\\n            // Set the maturity scale for the Series (needed for `redeem` methods)\\n            series[adapter][maturity].mscale = mscale;\\n            if (mscale > _series.maxscale) {\\n                series[adapter][maturity].maxscale = mscale;\\n            }\\n\\n            (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\\n\\n            address stakeDst = adapterMeta[adapter].enabled ? cup : _series.sponsor;\\n            ERC20(target).safeTransferFrom(adapter, cup, _series.reward);\\n            series[adapter][maturity].reward = 0;\\n            ERC20(stake).safeTransferFrom(adapter, stakeDst, stakeSize);\\n        }\\n\\n        emit Backfilled(adapter, maturity, mscale, _usrs, _lscales);\\n    }\\n\\n    /* ========== INTERNAL VIEWS ========== */\\n\\n    function _exists(address adapter, uint256 maturity) internal view returns (bool) {\\n        return series[adapter][maturity].pt != address(0);\\n    }\\n\\n    function _settled(address adapter, uint256 maturity) internal view returns (bool) {\\n        return series[adapter][maturity].mscale > 0;\\n    }\\n\\n    function _canBeSettled(address adapter, uint256 maturity) internal view returns (bool) {\\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\\n        // If the sender is the sponsor for the Series\\n        if (msg.sender == series[adapter][maturity].sponsor) {\\n            return maturity - SPONSOR_WINDOW <= block.timestamp && cutoff >= block.timestamp;\\n        } else {\\n            return maturity + SPONSOR_WINDOW < block.timestamp && cutoff >= block.timestamp;\\n        }\\n    }\\n\\n    function _isValid(address adapter, uint256 maturity) internal view returns (bool) {\\n        (uint256 minm, uint256 maxm) = Adapter(adapter).getMaturityBounds();\\n        if (maturity < block.timestamp + minm || maturity > block.timestamp + maxm) return false;\\n        (, , uint256 day, uint256 hour, uint256 minute, uint256 second) = DateTime.timestampToDateTime(maturity);\\n\\n        if (hour != 0 || minute != 0 || second != 0) return false;\\n        uint256 mode = Adapter(adapter).mode();\\n        if (mode == 0) {\\n            return day == 1;\\n        }\\n        if (mode == 1) {\\n            return DateTime.getDayOfWeek(maturity) == 1;\\n        }\\n        return false;\\n    }\\n\\n    /* ========== INTERNAL UTILS ========== */\\n\\n    function _setAdapter(address adapter, bool isOn) internal {\\n        AdapterMeta memory am = adapterMeta[adapter];\\n        if (am.enabled == isOn) revert Errors.ExistingValue();\\n        am.enabled = isOn;\\n\\n        // If this adapter is being added for the first time\\n        if (isOn && am.id == 0) {\\n            am.id = ++adapterCounter;\\n            adapterAddresses[am.id] = adapter;\\n        }\\n\\n        // Set level and target (can only be done once);\\n        am.level = uint248(Adapter(adapter).level());\\n        adapterMeta[adapter] = am;\\n        emit AdapterChanged(adapter, am.id, isOn);\\n    }\\n\\n    /* ========== PUBLIC GETTERS ========== */\\n\\n    /// @notice Returns address of Principal Token\\n    function pt(address adapter, uint256 maturity) public view returns (address) {\\n        return series[adapter][maturity].pt;\\n    }\\n\\n    /// @notice Returns address of Yield Token\\n    function yt(address adapter, uint256 maturity) public view returns (address) {\\n        return series[adapter][maturity].yt;\\n    }\\n\\n    function mscale(address adapter, uint256 maturity) public view returns (uint256) {\\n        return series[adapter][maturity].mscale;\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyYT(address adapter, uint256 maturity) {\\n        if (series[adapter][maturity].yt != msg.sender) revert Errors.OnlyYT();\\n        _;\\n    }\\n\\n    /* ========== LOGS ========== */\\n\\n    /// @notice Admin\\n    event Backfilled(\\n        address indexed adapter,\\n        uint256 indexed maturity,\\n        uint256 mscale,\\n        address[] _usrs,\\n        uint256[] _lscales\\n    );\\n    event GuardChanged(address indexed adapter, uint256 cap);\\n    event AdapterChanged(address indexed adapter, uint256 indexed id, bool indexed isOn);\\n    event PeripheryChanged(address indexed periphery);\\n\\n    /// @notice Series lifecycle\\n    /// *---- beginning\\n    event SeriesInitialized(\\n        address adapter,\\n        uint256 indexed maturity,\\n        address pt,\\n        address yt,\\n        address indexed sponsor,\\n        address indexed target\\n    );\\n    /// -***- middle\\n    event Issued(address indexed adapter, uint256 indexed maturity, uint256 balance, address indexed sender);\\n    event Combined(address indexed adapter, uint256 indexed maturity, uint256 balance, address indexed sender);\\n    event Collected(address indexed adapter, uint256 indexed maturity, uint256 collected);\\n    /// ----* end\\n    event SeriesSettled(address indexed adapter, uint256 indexed maturity, address indexed settler);\\n    event PTRedeemed(address indexed adapter, uint256 indexed maturity, uint256 redeemed);\\n    event YTRedeemed(address indexed adapter, uint256 indexed maturity, uint256 redeemed);\\n    /// *----* misc\\n    event GuardedChanged(bool indexed guarded);\\n    event PermissionlessChanged(bool indexed permissionless);\\n}\\n\\ncontract TokenHandler is Trust {\\n    /// @notice Program state\\n    address public divider;\\n\\n    constructor() Trust(msg.sender) {}\\n\\n    function init(address _divider) external requiresTrust {\\n        if (divider != address(0)) revert Errors.AlreadyInitialized();\\n        divider = _divider;\\n    }\\n\\n    function deploy(\\n        address adapter,\\n        uint248 id,\\n        uint256 maturity\\n    ) external returns (address pt, address yt) {\\n        if (msg.sender != divider) revert Errors.OnlyDivider();\\n\\n        ERC20 target = ERC20(Adapter(adapter).target());\\n        uint8 decimals = target.decimals();\\n        string memory symbol = target.symbol();\\n        (string memory d, string memory m, string memory y) = DateTime.toDateString(maturity);\\n        string memory date = DateTime.format(maturity);\\n        string memory datestring = string(abi.encodePacked(d, \\\"-\\\", m, \\\"-\\\", y));\\n        string memory adapterId = DateTime.uintToString(id);\\n        pt = address(\\n            new Token(\\n                string(abi.encodePacked(date, \\\" \\\", symbol, \\\" Sense Principal Token, A\\\", adapterId)),\\n                string(abi.encodePacked(\\\"sP-\\\", symbol, \\\":\\\", datestring, \\\":\\\", adapterId)),\\n                decimals,\\n                divider\\n            )\\n        );\\n\\n        yt = address(\\n            new YT(\\n                adapter,\\n                maturity,\\n                string(abi.encodePacked(date, \\\" \\\", symbol, \\\" Sense Yield Token, A\\\", adapterId)),\\n                string(abi.encodePacked(\\\"sY-\\\", symbol, \\\":\\\", datestring, \\\":\\\", adapterId)),\\n                decimals,\\n                divider\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xf6844d67e70c2f11522133173ed85cfaf94d2bf6f2bc35667af63a46585f855f\",\"license\":\"AGPL-3.0-only\"},\"@sense-finance/v1-core/src/adapters/abstract/BaseAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\n// External references\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\nimport { SafeTransferLib } from \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\nimport { IERC3156FlashLender } from \\\"../../external/flashloan/IERC3156FlashLender.sol\\\";\\nimport { IERC3156FlashBorrower } from \\\"../../external/flashloan/IERC3156FlashBorrower.sol\\\";\\n\\n// Internal references\\nimport { Divider } from \\\"../../Divider.sol\\\";\\nimport { Errors } from \\\"@sense-finance/v1-utils/src/libs/Errors.sol\\\";\\n\\n/// @title Assign value to Target tokens\\nabstract contract BaseAdapter is IERC3156FlashLender {\\n    using SafeTransferLib for ERC20;\\n\\n    /* ========== CONSTANTS ========== */\\n\\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n\\n    /* ========== PUBLIC IMMUTABLES ========== */\\n\\n    /// @notice Sense core Divider address\\n    address public immutable divider;\\n\\n    /// @notice Target token to divide\\n    address public immutable target;\\n\\n    /// @notice Underlying for the Target\\n    address public immutable underlying;\\n\\n    /// @notice Issuance fee\\n    uint128 public immutable ifee;\\n\\n    /// @notice adapter params\\n    AdapterParams public adapterParams;\\n\\n    /* ========== DATA STRUCTURES ========== */\\n\\n    struct AdapterParams {\\n        /// @notice Oracle address\\n        address oracle;\\n        /// @notice Token to stake at issuance\\n        address stake;\\n        /// @notice Amount to stake at issuance\\n        uint256 stakeSize;\\n        /// @notice Min maturity (seconds after block.timstamp)\\n        uint256 minm;\\n        /// @notice Max maturity (seconds after block.timstamp)\\n        uint256 maxm;\\n        /// @notice WAD number representing the percentage of the total\\n        /// principal that's set aside for Yield Tokens (e.g. 0.1e18 means that 10% of the principal is reserved).\\n        /// @notice If `0`, it means no principal is set aside for Yield Tokens\\n        uint64 tilt;\\n        /// @notice The number this function returns will be used to determine its access by checking for binary\\n        /// digits using the following scheme:\\u00a0<onRedeem(y/n)><collect(y/n)><combine(y/n)><issue(y/n)>\\n        /// (e.g. 0101 enables `collect` and `issue`, but not `combine`)\\n        uint48 level;\\n        /// @notice 0 for monthly, 1 for weekly\\n        uint16 mode;\\n    }\\n\\n    /* ========== METADATA STORAGE ========== */\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    constructor(\\n        address _divider,\\n        address _target,\\n        address _underlying,\\n        uint128 _ifee,\\n        AdapterParams memory _adapterParams\\n    ) {\\n        divider = _divider;\\n        target = _target;\\n        underlying = _underlying;\\n        ifee = _ifee;\\n        adapterParams = _adapterParams;\\n\\n        name = string(abi.encodePacked(ERC20(_target).name(), \\\" Adapter\\\"));\\n        symbol = string(abi.encodePacked(ERC20(_target).symbol(), \\\"-adapter\\\"));\\n\\n        ERC20(_target).safeApprove(divider, type(uint256).max);\\n        ERC20(_adapterParams.stake).safeApprove(divider, type(uint256).max);\\n    }\\n\\n    /// @notice Loan `amount` target to `receiver`, and takes it back after the callback.\\n    /// @param receiver The contract receiving target, needs to implement the\\n    /// `onFlashLoan(address user, address adapter, uint256 maturity, uint256 amount)` interface.\\n    /// @param amount The amount of target lent.\\n    /// @param data (encoded adapter address, maturity and YT amount the use has sent in)\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address, /* fee */\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\\n        ERC20(target).safeTransfer(address(receiver), amount);\\n        bytes32 keccak = IERC3156FlashBorrower(receiver).onFlashLoan(msg.sender, target, amount, 0, data);\\n        if (keccak != CALLBACK_SUCCESS) revert Errors.FlashCallbackFailed();\\n        ERC20(target).safeTransferFrom(address(receiver), address(this), amount);\\n        return true;\\n    }\\n\\n    /* ========== REQUIRED VALUE GETTERS ========== */\\n\\n    /// @notice Calculate and return this adapter's Scale value for the current timestamp. To be overriden by child contracts\\n    /// @dev For some Targets, such as cTokens, this is simply the exchange rate, or `supply cToken / supply underlying`\\n    /// @dev For other Targets, such as AMM LP shares, specialized logic will be required\\n    /// @dev This function _must_ return a WAD number representing the current exchange rate\\n    /// between the Target and the Underlying.\\n    /// @return value WAD Scale value\\n    function scale() external virtual returns (uint256);\\n\\n    /// @notice Cached scale value getter\\n    /// @dev For situations where you need scale from a view function\\n    function scaleStored() external view virtual returns (uint256);\\n\\n    /// @notice Returns the current price of the underlying in ETH terms\\n    function getUnderlyingPrice() external view virtual returns (uint256);\\n\\n    /* ========== REQUIRED UTILITIES ========== */\\n\\n    /// @notice Deposits underlying `amount`in return for target. Must be overriden by child contracts\\n    /// @param amount Underlying amount\\n    /// @return amount of target returned\\n    function wrapUnderlying(uint256 amount) external virtual returns (uint256);\\n\\n    /// @notice Deposits target `amount`in return for underlying. Must be overriden by child contracts\\n    /// @param amount Target amount\\n    /// @return amount of underlying returned\\n    function unwrapTarget(uint256 amount) external virtual returns (uint256);\\n\\n    function flashFee(address token, uint256) external view returns (uint256) {\\n        if (token != target) revert Errors.TokenNotSupported();\\n        return 0;\\n    }\\n\\n    function maxFlashLoan(address token) external view override returns (uint256) {\\n        return ERC20(token).balanceOf(address(this));\\n    }\\n\\n    /* ========== OPTIONAL HOOKS ========== */\\n\\n    /// @notice Notification whenever the Divider adds or removes Target\\n    function notify(\\n        address, /* usr */\\n        uint256, /* amt */\\n        bool /* join */\\n    ) public virtual {\\n        return;\\n    }\\n\\n    /// @notice Hook called whenever a user redeems PT\\n    function onRedeem(\\n        uint256, /* uBal */\\n        uint256, /* mscale */\\n        uint256, /* maxscale */\\n        uint256 /* tBal */\\n    ) public virtual {\\n        return;\\n    }\\n\\n    /* ========== PUBLIC STORAGE ACCESSORS ========== */\\n\\n    function getMaturityBounds() external view virtual returns (uint256, uint256) {\\n        return (adapterParams.minm, adapterParams.maxm);\\n    }\\n\\n    function getStakeAndTarget()\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            uint256\\n        )\\n    {\\n        return (target, adapterParams.stake, adapterParams.stakeSize);\\n    }\\n\\n    function mode() external view returns (uint256) {\\n        return adapterParams.mode;\\n    }\\n\\n    function tilt() external view returns (uint256) {\\n        return adapterParams.tilt;\\n    }\\n\\n    function level() external view returns (uint256) {\\n        return adapterParams.level;\\n    }\\n}\\n\",\"keccak256\":\"0xda0e2780d7f4c37511bd3fffbcef76df3b5b7f6818db482d2e5e341048af9c0b\",\"license\":\"AGPL-3.0-only\"},\"@sense-finance/v1-core/src/external/DateTime.sol\":{\"content\":\"pragma solidity 0.8.15;\\n\\n/// @author Taken from: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\nlibrary DateTime {\\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 constant SECONDS_PER_MINUTE = 60;\\n    int256 constant OFFSET19700101 = 2440588;\\n\\n    function timestampToDate(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function timestampToDateTime(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day,\\n            uint256 hour,\\n            uint256 minute,\\n            uint256 second\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint256 secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n        secs = secs % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n        second = secs % SECONDS_PER_MINUTE;\\n    }\\n\\n    function toDateString(uint256 _timestamp)\\n        internal\\n        pure\\n        returns (\\n            string memory d,\\n            string memory m,\\n            string memory y\\n        )\\n    {\\n        (uint256 year, uint256 month, uint256 day) = timestampToDate(_timestamp);\\n        d = uintToString(day);\\n        m = uintToString(month);\\n        y = uintToString(year);\\n        // append a 0 to numbers < 10 so we should, e.g, 01 instead of just 1\\n        if (day < 10) d = string(abi.encodePacked(\\\"0\\\", d));\\n        if (month < 10) m = string(abi.encodePacked(\\\"0\\\", m));\\n    }\\n\\n    function format(uint256 _timestamp) internal pure returns (string memory datestring) {\\n        string[12] memory months = [\\n            \\\"Jan\\\",\\n            \\\"Feb\\\",\\n            \\\"Mar\\\",\\n            \\\"Apr\\\",\\n            \\\"May\\\",\\n            \\\"June\\\",\\n            \\\"July\\\",\\n            \\\"Aug\\\",\\n            \\\"Sept\\\",\\n            \\\"Oct\\\",\\n            \\\"Nov\\\",\\n            \\\"Dec\\\"\\n        ];\\n        (uint256 year, uint256 month, uint256 day) = timestampToDate(_timestamp);\\n        uint256 last = day % 10;\\n        string memory suffix = \\\"th\\\";\\n        if (day < 11 || day > 20) {\\n            if (last == 1) suffix = \\\"st\\\";\\n            if (last == 2) suffix = \\\"nd\\\";\\n            if (last == 3) suffix = \\\"rd\\\";\\n        }\\n        return string(abi.encodePacked(uintToString(day), suffix, \\\" \\\", months[month - 1], \\\" \\\", uintToString(year)));\\n    }\\n\\n    function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 dayOfWeek) {\\n        uint256 _days = timestamp / SECONDS_PER_DAY;\\n        dayOfWeek = ((_days + 3) % 7) + 1;\\n    }\\n\\n    /// Taken from https://stackoverflow.com/questions/47129173/how-to-convert-uint-to-string-in-solidity\\n    function uintToString(uint256 _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) return \\\"0\\\";\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // days = day\\n    //      - 32075\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n    //      - offset\\n    // ------------------------------------------------------------------------\\n    function _daysFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (uint256 _days) {\\n        require(year >= 1970);\\n        int256 _year = int256(year);\\n        int256 _month = int256(month);\\n        int256 _day = int256(day);\\n\\n        int256 __days = _day -\\n            32075 +\\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n            4 +\\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n            12 -\\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n            4 -\\n            OFFSET19700101;\\n\\n        _days = uint256(__days);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n}\\n\",\"keccak256\":\"0x161ffa42bb0b7508a9372db90a7710088adbfb38cee34cdf523ff932b9b51043\"},\"@sense-finance/v1-core/src/external/FixedMath.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\n/// @title Fixed point arithmetic library\\n/// @author Taken from https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol\\nlibrary FixedMath {\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant RAY = 1e27;\\n\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256) {\\n        return mulDivDown(x, y, baseUnit); // Equivalent to (x * y) / baseUnit rounded down.\\n    }\\n\\n    function fmul(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function fmulUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256) {\\n        return mulDivUp(x, y, baseUnit); // Equivalent to (x * y) / baseUnit rounded up.\\n    }\\n\\n    function fmulUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256) {\\n        return mulDivDown(x, baseUnit, y); // Equivalent to (x * baseUnit) / y rounded down.\\n    }\\n\\n    function fdiv(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function fdivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256) {\\n        return mulDivUp(x, baseUnit, y); // Equivalent to (x * baseUnit) / y rounded up.\\n    }\\n\\n    function fdivUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x466c07d32dda6d18099092be426495d84246b84d2654f212f69a623a1a63847d\",\"license\":\"AGPL-3.0-only\"},\"@sense-finance/v1-core/src/external/flashloan/IERC3156FlashBorrower.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\ninterface IERC3156FlashBorrower {\\n    /// @dev Receive a flash loan.\\n    /// @param initiator The initiator of the loan.\\n    /// @param token The loan currency.\\n    /// @param amount The amount of tokens lent.\\n    /// @param fee The additional amount of tokens to repay.\\n    /// @param data Arbitrary data structure, intended to contain user-defined parameters.\\n    /// @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\",\"keccak256\":\"0xa2007326dfc89668d1864d688373d7e1ee07fee48f605d4f6726224004bdc8e5\"},\"@sense-finance/v1-core/src/external/flashloan/IERC3156FlashLender.sol\":{\"content\":\"pragma solidity ^0.8.0;\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface IERC3156FlashLender {\\n    /// @dev The amount of currency available to be lent.\\n    /// @param token The loan currency.\\n    /// @return The amount of `token` that can be borrowed.\\n    function maxFlashLoan(address token) external view returns (uint256);\\n\\n    /// @dev The fee to be charged for a given loan.\\n    /// @param token The loan currency.\\n    /// @param amount The amount of tokens lent.\\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n    function flashFee(address token, uint256 amount) external view returns (uint256);\\n\\n    /// @dev Initiate a flash loan.\\n    /// @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n    /// @param token The loan currency.\\n    /// @param amount The amount of tokens lent.\\n    /// @param data Arbitrary data structure, intended to contain user-defined parameters.\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc91333a7ff49db20853c817de2c277a0559a1ee75eb1deeb7d2096a5d1022d61\"},\"@sense-finance/v1-core/src/tokens/Token.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\n// External references\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\n\\n// Internal references\\nimport { Trust } from \\\"@sense-finance/v1-utils/src/Trust.sol\\\";\\n\\n/// @title Base Token\\ncontract Token is ERC20, Trust {\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        address _trusted\\n    ) ERC20(_name, _symbol, _decimals) Trust(_trusted) {}\\n\\n    /// @param usr The address to send the minted tokens\\n    /// @param amount The amount to be minted\\n    function mint(address usr, uint256 amount) public requiresTrust {\\n        _mint(usr, amount);\\n    }\\n\\n    /// @param usr The address from where to burn tokens from\\n    /// @param amount The amount to be burned\\n    function burn(address usr, uint256 amount) public requiresTrust {\\n        _burn(usr, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xe7ba2a15fdf5f1d20a10c108c5883cd3e35d473c262eee755e579d4e9272fa3a\",\"license\":\"AGPL-3.0-only\"},\"@sense-finance/v1-core/src/tokens/YT.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\n// Internal references\\nimport { Divider } from \\\"../Divider.sol\\\";\\nimport { Token } from \\\"./Token.sol\\\";\\n\\n/// @title Yield Token\\n/// @notice Strips off excess before every transfer\\ncontract YT is Token {\\n    address public immutable adapter;\\n    address public immutable divider;\\n    uint256 public immutable maturity;\\n\\n    constructor(\\n        address _adapter,\\n        uint256 _maturity,\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        address _divider\\n    ) Token(_name, _symbol, _decimals, _divider) {\\n        adapter = _adapter;\\n        maturity = _maturity;\\n        divider = _divider;\\n    }\\n\\n    function collect() external returns (uint256 _collected) {\\n        return Divider(divider).collect(msg.sender, adapter, maturity, 0, address(0));\\n    }\\n\\n    function transfer(address to, uint256 value) public override returns (bool) {\\n        Divider(divider).collect(msg.sender, adapter, maturity, value, to);\\n        return super.transfer(to, value);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public override returns (bool) {\\n        if (value > 0) Divider(divider).collect(from, adapter, maturity, value, to);\\n        return super.transferFrom(from, to, value);\\n    }\\n}\\n\",\"keccak256\":\"0x81bdc71bc663bd88015cdf4e43c235345b7479f5d86e7b3a59ad64a8df3203f8\",\"license\":\"AGPL-3.0-only\"},\"@sense-finance/v1-utils/src/Trust.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.0;\\n\\n/// @notice Ultra minimal authorization logic for smart contracts.\\n/// @author From https://github.com/Rari-Capital/solmate/blob/fab107565a51674f3a3b5bfdaacc67f6179b1a9b/src/auth/Trust.sol\\nabstract contract Trust {\\n    event UserTrustUpdated(address indexed user, bool trusted);\\n\\n    mapping(address => bool) public isTrusted;\\n\\n    constructor(address initialUser) {\\n        isTrusted[initialUser] = true;\\n\\n        emit UserTrustUpdated(initialUser, true);\\n    }\\n\\n    function setIsTrusted(address user, bool trusted) public virtual requiresTrust {\\n        isTrusted[user] = trusted;\\n\\n        emit UserTrustUpdated(user, trusted);\\n    }\\n\\n    modifier requiresTrust() {\\n        require(isTrusted[msg.sender], \\\"UNTRUSTED\\\");\\n\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x2d3887076c81425d3954aea7735aebd9093e3df69c8132b1713fae4a34201d43\",\"license\":\"AGPL-3.0-only\"},\"@sense-finance/v1-utils/src/libs/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.4;\\n\\nlibrary Errors {\\n    // Auth\\n    error CombineRestricted();\\n    error IssuanceRestricted();\\n    error NotAuthorized();\\n    error OnlyYT();\\n    error OnlyDivider();\\n    error OnlyPeriphery();\\n    error OnlyPermissionless();\\n    error RedeemRestricted();\\n    error Untrusted();\\n\\n    // Adapters\\n    error TokenNotSupported();\\n    error FlashCallbackFailed();\\n    error SenderNotEligible();\\n    error TargetMismatch();\\n    error TargetNotSupported();\\n    error InvalidAdapterType();\\n    error PriceOracleNotFound();\\n\\n    // Divider\\n    error AlreadySettled();\\n    error CollectNotSettled();\\n    error GuardCapReached();\\n    error IssuanceFeeCapExceeded();\\n    error IssueOnSettle();\\n    error NotSettled();\\n\\n    // Input & validations\\n    error AlreadyInitialized();\\n    error DuplicateSeries();\\n    error ExistingValue();\\n    error InvalidAdapter();\\n    error InvalidMaturity();\\n    error InvalidParam();\\n    error NotImplemented();\\n    error OutOfWindowBoundaries();\\n    error SeriesDoesNotExist();\\n    error SwapTooSmall();\\n    error TargetParamsNotSet();\\n    error PoolParamsNotSet();\\n    error PTParamsNotSet();\\n    error AttemptFailed();\\n    error InvalidPrice();\\n    error BadContractInteration();\\n\\n    // Periphery\\n    error FactoryNotSupported();\\n    error FlashBorrowFailed();\\n    error FlashUntrustedBorrower();\\n    error FlashUntrustedLoanInitiator();\\n    error UnexpectedSwapAmount();\\n    error TooMuchLeftoverTarget();\\n\\n    // Fuse\\n    error AdapterNotSet();\\n    error FailedBecomeAdmin();\\n    error FailedAddTargetMarket();\\n    error FailedToAddPTMarket();\\n    error FailedAddLpMarket();\\n    error OracleNotReady();\\n    error PoolAlreadyDeployed();\\n    error PoolNotDeployed();\\n    error PoolNotSet();\\n    error SeriesNotQueued();\\n    error TargetExists();\\n    error TargetNotInFuse();\\n\\n    // Tokens\\n    error MintFailed();\\n    error RedeemFailed();\\n    error TransferFailed();\\n}\\n\",\"keccak256\":\"0x5eece5ee6069054e8485c7c799ad1ea764446248088ee16bc0ae08c84f0c52b9\",\"license\":\"AGPL-3.0-only\"},\"@sense-finance/v1-utils/src/libs/Levels.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.0;\\n\\nlibrary Levels {\\n    uint256 private constant _INIT_BIT = 0x1;\\n    uint256 private constant _ISSUE_BIT = 0x2;\\n    uint256 private constant _COMBINE_BIT = 0x4;\\n    uint256 private constant _COLLECT_BIT = 0x8;\\n    uint256 private constant _REDEEM_BIT = 0x10;\\n    uint256 private constant _REDEEM_HOOK_BIT = 0x20;\\n\\n    function initRestricted(uint256 level) internal pure returns (bool) {\\n        return level & _INIT_BIT != _INIT_BIT;\\n    }\\n\\n    function issueRestricted(uint256 level) internal pure returns (bool) {\\n        return level & _ISSUE_BIT != _ISSUE_BIT;\\n    }\\n\\n    function combineRestricted(uint256 level) internal pure returns (bool) {\\n        return level & _COMBINE_BIT != _COMBINE_BIT;\\n    }\\n\\n    function collectDisabled(uint256 level) internal pure returns (bool) {\\n        return level & _COLLECT_BIT != _COLLECT_BIT;\\n    }\\n\\n    function redeemRestricted(uint256 level) internal pure returns (bool) {\\n        return level & _REDEEM_BIT != _REDEEM_BIT;\\n    }\\n\\n    function redeemHookDisabled(uint256 level) internal pure returns (bool) {\\n        return level & _REDEEM_HOOK_BIT != _REDEEM_HOOK_BIT;\\n    }\\n}\\n\",\"keccak256\":\"0x6c71e17beb73fca7577fb8868086159303eaecb1b397a446e8891b42f73fd502\",\"license\":\"AGPL-3.0-only\"},\"lib/auto-roller/src/AutoRoller.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\nimport { FixedPointMathLib } from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport { SafeTransferLib } from \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\nimport { ReentrancyGuard } from \\\"solmate/src/utils/ReentrancyGuard.sol\\\";\\nimport { ERC4626 } from \\\"solmate/src/mixins/ERC4626.sol\\\";\\n\\nimport { DateTime } from \\\"./external/DateTime.sol\\\";\\n\\nimport { SafeCast } from \\\"./SafeCast.sol\\\";\\n\\nimport { BalancerVault } from \\\"./interfaces/BalancerVault.sol\\\";\\nimport { Space } from \\\"./interfaces/Space.sol\\\";\\n\\ninterface SpaceFactoryLike {\\n    function divider() external view returns (address);\\n    function create(address, uint256) external returns (address);\\n    function pools(address, uint256) external view returns (Space);\\n}\\n\\ninterface DividerLike {\\n    function series(address, uint256) external returns (address, uint48, address, uint96, address, uint256, uint256, uint256, uint256);\\n    function issue(address, uint256, uint256) external returns (uint256);\\n    function settleSeries(address, uint256) external;\\n    function mscale(address, uint256) external view returns (uint256);\\n    function redeem(address, uint256, uint256) external;\\n    function combine(address, uint256, uint256) external;\\n}\\n\\ninterface YTLike {\\n    function approve(address, uint256) external;\\n    function transfer(address, uint256) external;\\n    function collect() external returns (uint256);\\n    function balanceOf(address) external view returns (uint256);\\n}\\n\\ninterface PeripheryLike {\\n    function sponsorSeries(address, uint256, bool) external returns (ERC20, YTLike);\\n    function swapYTsForTarget(address, uint256, uint256) external returns (uint256);\\n    function create(address, uint256) external returns (address);\\n    function spaceFactory() external view returns (SpaceFactoryLike);\\n    function MIN_YT_SWAP_IN() external view returns (uint256);\\n}\\n\\ninterface OwnedAdapterLike {\\n    function target() external view returns (address);\\n    function underlying() external view returns (address);\\n    function ifee() external view returns (uint256);\\n    function openSponsorWindow() external;\\n    function scale() external returns (uint256);\\n    function scaleStored() external view returns (uint256);\\n    function getStakeAndTarget() external view returns (address,address,uint256);\\n    function setIsTrusted(address,bool) external;\\n}\\n\\ncontract AutoRoller is ERC4626, ReentrancyGuard {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n    using SafeCast for *;\\n\\n    /* ========== ERRORS ========== */\\n\\n    error ActivePhaseOnly();\\n    error UnrecognizedParam(bytes32 what);\\n    error InsufficientLiquidity();\\n    error RollWindowNotOpen();\\n    error OnlyAdapter();\\n    error InvalidSettler();\\n\\n    /* ========== CONSTANTS ========== */\\n\\n    uint32 internal constant MATURITY_NOT_SET = type(uint32).max;\\n    int256 internal constant WITHDRAWAL_GUESS_OFFSET = 0.95e18; // Offset from the number of assets in this contract the first withdrawal guess will be made.\\n\\n    /* ========== IMMUTABLES ========== */\\n\\n    DividerLike      internal immutable divider;\\n    BalancerVault    internal immutable balancerVault;\\n    OwnedAdapterLike public   immutable adapter;\\n\\n    uint256 internal immutable ifee; // Cached issuance fee.\\n    uint256 internal immutable minSwapAmount; // Min number of PTs that can be swapped out when exiting.\\n    uint256 internal immutable firstDeposit; // Size of the first deposit that gets locked in the contract permanently.\\n    uint256 internal immutable maxError; // A conservative buffer for \\\"rounding\\\" swap previews that accounts for compounded pow of imprecision.\\n    address internal immutable rewardRecipient; // Recipient address for any unexpected tokens that end up in this contract.\\n\\n    /* ========== MUTABLE STORAGE ========== */\\n\\n    PeripheryLike    internal periphery;\\n    SpaceFactoryLike internal spaceFactory;\\n    address          internal owner; // Admin that can set params.\\n    RollerUtils      internal utils; // Utility contract with convenience getter functions.\\n\\n    // Active Series\\n    YTLike  internal yt;\\n    ERC20   internal pt;\\n    Space   internal space;\\n    bytes32 internal poolId;\\n    address internal lastRoller; // Last address to call roll.\\n\\n    // Separate slots to meet contract size limits.\\n    uint256 public   maturity = MATURITY_NOT_SET;\\n    uint256 internal initScale;\\n    uint256 internal pti;\\n\\n    uint256 internal maxRate        = 53144e19; // Max implied rate stretched to Space pool's TS period. (531440% over 12 years \\u2248 200% APY)\\n    uint256 internal targetedRate   = 2.9e18; // Targeted implied rate stretched to Space pool's TS period. (2.9% over 12 years \\u2248 0.12% APY)\\n    uint256 internal targetDuration = 3; // Number of months or weeks in the future newly sponsored Series should mature.\\n\\n    uint256 public cooldown         = 10 days; // Length of mandatory cooldown period during which LPs can withdraw without slippage.\\n    uint256 public lastSettle; // Timestamp from when settlement was last called.\\n\\n    constructor(\\n        ERC20 _target,\\n        DividerLike _divider,\\n        address _periphery,\\n        address _spaceFactory,\\n        address _balancerVault,\\n        OwnedAdapterLike _adapter,\\n        RollerUtils _utils,\\n        address _rewardRecipient\\n    ) ERC4626(\\n        _target,\\n        string(abi.encodePacked(_target.name(), \\\" Sense Auto Roller\\\")),\\n        string(abi.encodePacked(_target.symbol(), \\\"-sAR\\\"))\\n    ) {\\n        divider       = _divider;\\n        periphery     = PeripheryLike(_periphery);\\n        spaceFactory  = SpaceFactoryLike(_spaceFactory);\\n        balancerVault = BalancerVault(_balancerVault);\\n\\n        // Allow the Divder to move this contract's Target for PT/YT issuance.\\n        _target.safeApprove(address(_divider), type(uint256).max);\\n\\n        // Allow Balancer to move this contract's Target for Space pools joins.\\n        _target.safeApprove(address(_balancerVault), type(uint256).max);\\n\\n        uint256 scalingFactor = 10**(18 - decimals);\\n\\n        minSwapAmount = (periphery.MIN_YT_SWAP_IN() - 1) / scalingFactor + 1; // Rounds up to cover low decimal tokens.\\n        maxError      = (1e7 - 1) / scalingFactor + 1;\\n        firstDeposit  = (0.01e18 - 1) / scalingFactor + 1;\\n\\n        adapter = _adapter;\\n        ifee    = _adapter.ifee(); // Assumption: ifee will not change. Don't break this assumption and expect good things.\\n        owner   = msg.sender;\\n        utils   = _utils;\\n        rewardRecipient = _rewardRecipient;\\n    }\\n\\n    /* ========== SERIES MANAGEMENT ========== */\\n\\n    /// @notice Roll into the next Series if there isn't an active series and the cooldown period has elapsed.\\n    function roll() external {\\n        if (maturity != MATURITY_NOT_SET) revert RollWindowNotOpen();\\n\\n        if (lastSettle == 0) {\\n            // If this is the first roll, lock some shares in by minting them for the zero address.\\n            // This prevents the contract from reaching an empty state during future active periods.\\n            deposit(firstDeposit, address(0));\\n        } else if (lastSettle + cooldown > block.timestamp) {\\n            revert RollWindowNotOpen();\\n        }\\n\\n        lastRoller = msg.sender;\\n        adapter.openSponsorWindow();\\n    }\\n\\n    /// @notice Sponsor a new Series, issue PTs, and migrate liquidity into the new Space pool.\\n    /// @dev We only expect this function to be called by this roller's adapter in the callback triggered within the adapter.openSponsorWindow call.\\n    ///      Assumption: all of this Vault's LP shares will have been exited before this function is called.\\n    /// @param stake the adapter's stake token address.\\n    /// @param stakeSize the adapter's stake size.\\n    function onSponsorWindowOpened(ERC20 stake, uint256 stakeSize) external {\\n        if (msg.sender != address(adapter)) revert OnlyAdapter();\\n\\n        stake.safeTransferFrom(lastRoller, address(this), stakeSize);\\n\\n        // Allow the Periphery to move stake for sponsoring the Series.\\n        stake.safeApprove(address(periphery), stakeSize);\\n\\n        uint256 _maturity = utils.getFutureMaturity(targetDuration);\\n\\n        // Assign Series data.\\n        (ERC20 _pt, YTLike _yt) = periphery.sponsorSeries(address(adapter), _maturity, true);\\n        (Space _space, bytes32 _poolId, uint256 _pti, uint256 _initScale) = utils.getSpaceData(periphery, OwnedAdapterLike(msg.sender), _maturity);\\n\\n        // Allow Balancer to move the new PTs for joins & swaps.\\n        _pt.approve(address(balancerVault), type(uint256).max);\\n\\n        // Allow Periphery to move the new YTs for swaps.\\n        _yt.approve(address(periphery), type(uint256).max);\\n\\n        ERC20 _asset = asset;\\n\\n        ERC20[] memory tokens = new ERC20[](2);\\n        tokens[1 - _pti] = _asset;\\n        tokens[_pti] = _pt;\\n\\n        uint256 targetBal = _asset.balanceOf(address(this));\\n\\n        // Get the reserve balances that would imply the given targetedRate in the Space pool,\\n        // assuming that we we're going to deposit the amount of Target currently in this contract.\\n        // In other words, this function simulating the reserve balances that would result from the actions:\\n        // 1) Use the some Target to issue PTs/YTs\\n        // 2) Deposit some amount of Target\\n        // 3) Swap PTs into the pool to initialize the targeted rate\\n        // 4) Deposit the rest of the PTs and Target in this contract (which remain in the exact ratio the pool expects)\\n        // Since we're determining the resulting reserve balances of these operations, we can issue exactly the amount of PTs we'll need to keep the ratio in the pool.\\n        (uint256 eqPTReserves, uint256 eqTargetReserves) = _space.getEQReserves(\\n            targetedRate < 0.01e18 ? 0.01e18 : targetedRate, // Don't let the pool start below 0.01% stretched yield\\n            _maturity,\\n            0, // PT reserves, starting with 0\\n            targetBal, // Target reserves, starting with the entire Target balance in this contract.\\n            targetBal.mulWadDown(_initScale), // Total supply, starting with Target * initScale, since that's the BPT supply if once deposit all of the Target.\\n            _space.g2() // Space fee, g2 because the swap we'll make to initialize these reserve balances is PT -> Target (see https://yield.is/YieldSpace.pdf section \\\"5 Fees\\\").\\n        );\\n\\n        // Calculate & issue an amount of PTs, such that all PTs are used to add liquidity while preserving the PT:Target reserve ratio in the Space Pool.\\n        uint256 targetForIssuance = _getTargetForIssuance(eqPTReserves, eqTargetReserves, targetBal, _initScale);\\n        divider.issue(address(adapter), _maturity, targetForIssuance);\\n\\n        uint256[] memory balances = new uint256[](2);\\n        balances[1 - _pti] = targetBal - targetForIssuance;\\n\\n        // Initialize the targeted rate in the Space pool with a join, a swap, and another join.\\n        _joinPool(\\n            _poolId,\\n            BalancerVault.JoinPoolRequest({\\n                assets: tokens,\\n                maxAmountsIn: balances,\\n                userData: abi.encode(balances, 0), // No min BPT out: first join.\\n                fromInternalBalance: false\\n            })\\n        );\\n        _swap(\\n            BalancerVault.SingleSwap({\\n                poolId: _poolId,\\n                kind: BalancerVault.SwapKind.GIVEN_IN,\\n                assetIn: address(_pt),\\n                assetOut: address(tokens[1 - _pti]),\\n                amount: eqPTReserves.mulDivDown(balances[1 - _pti], targetBal),\\n                userData: hex\\\"\\\"\\n            })\\n        );\\n\\n        balances[_pti    ] = _pt.balanceOf(address(this));\\n        balances[1 - _pti] = _asset.balanceOf(address(this));\\n\\n        _joinPool(\\n            _poolId,\\n            BalancerVault.JoinPoolRequest({\\n                assets: tokens,\\n                maxAmountsIn: balances,\\n                userData: abi.encode(balances, 0), // No min BPT out: the pool was created in this tx and the join can't be sandwiched.\\n                fromInternalBalance: false\\n            })\\n        );\\n\\n        // Cache Series data.\\n        space  = _space;\\n        poolId = _poolId;\\n        pt     = _pt;\\n        yt     = _yt;\\n\\n        // Combined single SSTORE.\\n        initScale = _initScale;\\n        maturity  = _maturity; // OK until Feb 07, 2106\\n        pti       = _pti;\\n\\n        emit Rolled(_maturity, uint256(_initScale), address(_space), msg.sender);\\n    }\\n\\n    /// @notice Settle the active Series, transfer stake and ifees to the settler, and enter a cooldown phase.\\n    /// @dev Because the auto-roller is the series sponsor from the Divider's perspective, this.settle is the only entrypoint for athe lastRoller to settle during the series' sponsor window.\\n    ///      More info on the series lifecylce: https://docs.sense.finance/docs/series-lifecycle-detail/#phase-3-settling.\\n    function settle() public {\\n        if(msg.sender != lastRoller) revert InvalidSettler();\\n\\n        uint256 assetBalPre = asset.balanceOf(address(this));\\n        divider.settleSeries(address(adapter), maturity); // Settlement will fail if maturity hasn't been reached.\\n        uint256 assetBalPost = asset.balanceOf(address(this));\\n\\n        asset.safeTransfer(msg.sender, assetBalPost - assetBalPre); // Send issuance fees to the sender.\\n\\n        (, address stake, uint256 stakeSize) = adapter.getStakeAndTarget();\\n        if (stake != address(asset)) {\\n            ERC20(stake).safeTransfer(msg.sender, stakeSize);\\n        }\\n\\n        startCooldown();\\n    }\\n\\n    /// @notice Enter a cooldown phase where users can redeem without slippage. Often this will be initiated by this.settle,\\n    ///         but it can be called externally if the Series was settled externally.\\n    function startCooldown() public {\\n        require(divider.mscale(address(adapter), maturity) != 0);\\n\\n        ERC20[] memory tokens = new ERC20[](2);\\n        tokens[1 - pti] = asset;\\n        tokens[pti    ] = pt;\\n\\n        _exitPool(\\n            poolId,\\n            BalancerVault.ExitPoolRequest({\\n                assets: tokens,\\n                minAmountsOut: new uint256[](2),\\n                userData: abi.encode(space.balanceOf(address(this))),\\n                toInternalBalance: false\\n            })\\n        );\\n\\n        divider.redeem(address(adapter), maturity, pt.balanceOf(address(this))); // Burns the PTs.\\n        yt.collect(); // Burns the YTs.\\n\\n        // Calculate the initial market fixed rate for the upcoming series, using the historical avg Target rate across the previous series.\\n        targetedRate = utils.getNewTargetedRate(targetedRate, address(adapter), maturity, space);\\n\\n        maturity   = MATURITY_NOT_SET;\\n        lastSettle = uint32(block.timestamp);\\n        delete pt; delete yt; delete space; delete pti; delete poolId; delete initScale; // Re-set variables to defaults, collect gas refund.\\n    }\\n\\n    /* ========== 4626 SPEC ========== */\\n    // see: https://eips.ethereum.org/EIPS/eip-4626\\n\\n    /// @dev Collect asset from roller's YT balance & densify shares before depositing\\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\\n        if (maturity != MATURITY_NOT_SET) yt.collect();\\n        return super.deposit(assets, receiver);\\n    }\\n\\n    /// @dev Collect asset from roller's YT balance & densify shares before minting\\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\\n        if (maturity != MATURITY_NOT_SET) yt.collect();\\n        return super.mint(shares, receiver);\\n    }\\n\\n    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256) {\\n        if (maturity != MATURITY_NOT_SET) yt.collect();\\n        return super.redeem(shares, receiver, owner);\\n    }\\n\\n    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {\\n        if (maturity != MATURITY_NOT_SET) yt.collect();\\n        return super.withdraw(assets, receiver, owner);\\n    }\\n\\n    /// @dev exit LP shares commensurate the given number of shares, and sell the excess PTs or YTs into Target if possible.\\n    function beforeWithdraw(uint256, uint256 shares) internal override {\\n        if (maturity != MATURITY_NOT_SET) {\\n            (uint256 excessBal, bool isExcessPTs) = _exitAndCombine(shares);\\n\\n            if (excessBal < minSwapAmount) return;\\n\\n            if (isExcessPTs) {\\n                _swap(\\n                    BalancerVault.SingleSwap({\\n                        poolId: poolId,\\n                        kind: BalancerVault.SwapKind.GIVEN_IN,\\n                        assetIn: address(pt),\\n                        assetOut: address(asset),\\n                        amount: excessBal,\\n                        userData: hex\\\"\\\"\\n                    })\\n                );\\n            } else {\\n                periphery.swapYTsForTarget(address(adapter), maturity, excessBal); // Swapping YTs will fail if there isn't enough liquidity.\\n            }\\n        }\\n    }\\n\\n    /// @dev Joins the Space pool, issuing PTs in order to match the current pool's ratio of Target:PT\\n    function afterDeposit(uint256, uint256 shares) internal override {\\n        if (maturity != MATURITY_NOT_SET) {\\n            uint256 _supply = totalSupply; // Saves extra SLOADs.\\n            bytes32 _poolId = poolId;\\n            uint256 _pti    = pti;\\n\\n            (ERC20[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(_poolId);\\n\\n            uint256 assetBal = asset.balanceOf(address(this));\\n            uint256 targetToJoin = _supply - shares == 0 ? // _supply - shares b/c this is after minting new shares.\\n                shares.mulDivUp(balances[1 - _pti], space.adjustedTotalSupply()) :\\n                assetBal - _getTargetForIssuance(balances[_pti], balances[1 - _pti], assetBal, adapter.scaleStored());\\n\\n            balances[1 - _pti] = targetToJoin;\\n\\n            if (assetBal - targetToJoin > 0) { // Assumption: this is false if Space has only Target liquidity.\\n                balances[_pti] = divider.issue(address(adapter), maturity, assetBal - targetToJoin);\\n            }\\n\\n            _joinPool(\\n                _poolId,\\n                BalancerVault.JoinPoolRequest({\\n                    assets: tokens,\\n                    maxAmountsIn: balances,\\n                    userData: abi.encode(balances, 0),\\n                    fromInternalBalance: false\\n                })\\n            );\\n        }\\n    }\\n\\n    /// @notice Calculates the total assets of this vault using the current spot prices, with no regard for slippage.\\n    function totalAssets() public view override returns (uint256) {\\n        if (maturity == MATURITY_NOT_SET) {\\n            return asset.balanceOf(address(this));\\n        }\\n        else {\\n            Space _space = space;\\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\\n\\n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, ) = _decomposeShares(ptReserves, targetReserves, totalSupply, true);\\n\\n            uint256 ptSpotPrice = _space.getPriceFromImpliedRate(\\n                (ptReserves + _space.adjustedTotalSupply()).divWadDown(targetReserves.mulWadDown(initScale)) - 1e18\\n            ); // PT price in Target.\\n\\n            uint256 scale = adapter.scaleStored();\\n\\n            if (ptBal >= ytBal) {\\n                // Target + combined PTs/YTs + PT spot value in Target.\\n                return targetBal + ytBal.divWadDown(scale) + ptSpotPrice.mulWadDown(ptBal - ytBal);\\n            } else {\\n                uint256 ytSpotPrice = (1e18 - ptSpotPrice.mulWadDown(scale)).divWadDown(scale);\\n\\n                // Target + combined PTs/YTs + YT spot value in Target.\\n                return targetBal + ptBal.divWadDown(scale) + ytSpotPrice.mulWadDown(ytBal - ptBal);\\n            }\\n        }\\n    }\\n\\n    /// @notice The same as convertToShares, except that slippage is considered.\\n    /// @dev Preview the number of new LP shares that would be minted by joining with the given amount of Target, then use that\\n    ///      as a percentage of the total number of LP shares held in this contract to preview the number of new roller shares.\\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\\n        if (maturity == MATURITY_NOT_SET) {\\n            return super.previewDeposit(assets);\\n        } else {\\n            Space _space = space;\\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\\n\\n            // Calculate how much Target we'll end up joining the pool with, and use that to preview minted LP shares.\\n            uint256 previewedLPBal = (assets - _getTargetForIssuance(ptReserves, targetReserves, assets, adapter.scaleStored()))\\n                .mulDivDown(_space.adjustedTotalSupply(), targetReserves);\\n\\n            uint256 assetBal = asset.balanceOf(address(this));\\n            uint256 assetBalLP = space.balanceOf(address(this)).mulDivDown(assets, previewedLPBal);\\n            uint256 assetBalPT = pt.balanceOf(address(this)).divWadUp(adapter.scaleStored().mulWadDown(1e18 - ifee));\\n\\n            // Shares represent proportional ownership of LP shares the vault holds.\\n            return previewedLPBal.mulDivDown(totalSupply, _space.balanceOf(address(this)))\\n                .mulDivDown(assetBalLP, assetBalPT + assetBalLP + assetBal);\\n        }\\n    }\\n\\n    /// @dev Preview the amount of Target needed to mint the given number of shares by determining how much of\\n    ///      each asset in this contract the given number of shares represent, then conver that all into Target.\\n    function previewMint(uint256 shares) public view override returns (uint256) {\\n        if (maturity == MATURITY_NOT_SET) {\\n            return super.previewMint(shares);\\n        } else {\\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\\n\\n            (uint256 targetToJoin, uint256 ptsToJoin, , ) = _decomposeShares(ptReserves, targetReserves, shares, true);\\n\\n            return targetToJoin + ptsToJoin.divWadUp(adapter.scaleStored().mulWadDown(1e18 - ifee)) + 1; // targetToJoin + targetToIssue\\n        }\\n    }\\n\\n    /// @notice The same as convertToAssets, except that slippage is considered.\\n    function previewRedeem(uint256 shares) public view override returns (uint256) {\\n        if (maturity == MATURITY_NOT_SET) {\\n            return super.previewRedeem(shares);\\n        } else {\\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\\n\\n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, uint256 lpBal) = _decomposeShares(ptReserves, targetReserves, shares, false);\\n\\n            uint256 scale = adapter.scaleStored();\\n\\n            ptReserves     = ptReserves - ptBal;\\n            targetReserves = targetReserves - targetBal;\\n\\n            // Adjust balances for loose asset share.\\n            ptBal     = ptBal     + shares.mulDivDown(pt.balanceOf(address(this)), totalSupply);\\n            targetBal = targetBal + shares.mulDivDown(asset.balanceOf(address(this)), totalSupply);\\n            uint256 spaceSupply = space.adjustedTotalSupply() - lpBal;\\n\\n            if (ptBal > ytBal) {\\n                unchecked {\\n                    // If there isn't enough liquidity to sell all of the PTs, the swap preview will fail.\\n                    uint256 ptsToSell = ptBal - ytBal;\\n\\n                    uint256 targetOut = ptsToSell > minSwapAmount ?\\n                        space.onSwapPreview(\\n                            true,\\n                            true,\\n                            ptsToSell,\\n                            ptReserves,\\n                            targetReserves,\\n                            spaceSupply,\\n                            scale\\n                        ) : 0;\\n\\n                    // target + combined PTs/YTs + sold PTs - buffer for pow of discrepencies.\\n                    return targetBal + ytBal.divWadDown(scale) + targetOut - maxError;\\n                }\\n            } else {\\n                unchecked {\\n                    // Safety: an inequality check is done before ytBal - ptBal.\\n                    //         shares must be lte total supply, so ptReserves & targetReserves wil always be gte ptBal & targetBal.\\n                    uint256 ytsToSell = ytBal - ptBal;\\n\\n                    // Target from combining YTs with PTs - target needed to buy PTs.\\n                    uint256 targetOut = ytsToSell > minSwapAmount ?\\n                        ytsToSell.divWadDown(scale) - space.onSwapPreview(\\n                            false,\\n                            false,\\n                            ytsToSell,\\n                            targetReserves,\\n                            ptReserves,\\n                            spaceSupply,\\n                            scale\\n                        ) : 0;\\n\\n                    // target + combined PTs/YTs + sold YTs - buffer for pow of discrepencies.\\n                    return targetBal + ptBal.divWadDown(scale) + targetOut - maxError;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Amount of shares needed to redeem the given assets, erring on the side of overestimation.\\n    ///         The calculation for previewWithdraw is quite imprecise and expensive, so previewRedeem & redeem\\n    ///         should be favored over previewWithdraw & withdraw.\\n    function previewWithdraw(uint256 assets) public view override returns (uint256) {\\n        if (maturity == MATURITY_NOT_SET) {\\n            return super.previewWithdraw(assets);\\n        } else {\\n            uint256 _supply = totalSupply - firstDeposit;\\n\\n            int256 prevGuess  = _min(assets, _supply).safeCastToInt();\\n            int256 prevAnswer = previewRedeem(prevGuess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\\n\\n            int256 guess = prevGuess * WITHDRAWAL_GUESS_OFFSET / 1e18;\\n\\n            int256 supply = _supply.safeCastToInt();\\n\\n            // Find the root or get very close to it using the secant method, which is slightly more efficient than Newton's\\n            // method if the cost of evaluating f and f' is similar.\\n            for (uint256 i = 0; i < 20;) { // 20 chosen as a safe bound for convergence from practical trials.\\n                if (guess > supply) {\\n                    guess = supply;\\n                }\\n                int256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\\n\\n                if (answer > 0 && answer <= assets.mulWadDown(0.001e18).safeCastToInt() || (prevAnswer == answer)) { // Err on the side of overestimating shares needed. Could reduce precision for gas efficiency.\\n                    break;\\n                }\\n\\n                if (guess == supply && answer < 0) revert InsufficientLiquidity();\\n\\n                int256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\\n                prevGuess  = guess;\\n                prevAnswer = answer;\\n                guess      = nextGuess;\\n\\n                unchecked { ++i; }\\n            }\\n\\n            return guess.safeCastToUint() + maxError; // Buffer for pow discrepancies.\\n        }\\n    }\\n\\n    function maxWithdraw(address owner) public view override returns (uint256) {\\n        if (maturity == MATURITY_NOT_SET) {\\n            return super.maxWithdraw(owner);\\n        } else {\\n            return previewRedeem(maxRedeem(owner));\\n        }\\n    }\\n\\n    /// @notice Maximum number of shares the given owner can redeem, given Space pool liquidity constraints and the maxRate guard.\\n    function maxRedeem(address owner) public view override returns (uint256) { // No idiosyncratic owner restrictions.\\n        if (maturity == MATURITY_NOT_SET) {\\n            return super.maxRedeem(owner);\\n        } else {\\n            uint256 shares = balanceOf[owner];\\n\\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\\n\\n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, uint256 lpBal) = _decomposeShares(ptReserves, targetReserves, shares, false);\\n\\n            ptReserves     = ptReserves - ptBal;\\n            targetReserves = targetReserves - targetBal;\\n\\n            ptBal     = ptBal     + shares.mulDivDown(pt.balanceOf(address(this)), totalSupply);\\n            targetBal = targetBal + shares.mulDivDown(asset.balanceOf(address(this)), totalSupply);\\n            uint256 spaceSupply = space.adjustedTotalSupply() - lpBal;\\n\\n            bool isExcessPTs = ptBal > ytBal;\\n            uint256 diff = isExcessPTs ? ptBal - ytBal : ytBal - ptBal;\\n\\n            if (isExcessPTs) {\\n                uint256 maxPTSale = _maxPTSell(ptReserves, targetReserves, spaceSupply);\\n\\n                if (maxPTSale >= diff) {\\n                    // We have enough liquidity to handle the sale.\\n                    return shares;\\n                } else {\\n                    // For every unit of LP Share, the excess PT balance grows by \\\"hole\\\".\\n                    uint256 hole = diff.divWadDown(lpBal);\\n\\n                    // Determine how many shares we can redeem without exceeding sell limits.\\n                    return maxPTSale.divWadDown(hole).mulDivDown(totalSupply, space.balanceOf(address(this)));\\n                }\\n            } else {\\n                if (ptReserves >= diff) { // We can redeem YTs up to the point where there are PTs in Space to swap for.\\n                    // We have enough liquidity to handle the sale.\\n                    return shares;\\n                } else {\\n                    // For every unit of LP Share, the excess YT balance grows by \\\"hole\\\".\\n                    uint256 hole = diff.divWadDown(lpBal);\\n\\n                    // Determine how many shares we can redeem without exceeding sell limits.\\n                    return ptReserves.divWadDown(hole).mulDivDown(totalSupply, space.balanceOf(address(this)));\\n                }\\n            }\\n        }\\n    }\\n\\n    /* ========== 4626 EXTENSIONS ========== */\\n\\n    /// @notice Quick exit into the constituent assets.\\n    /// @param shares Number of shares to eject with.\\n    /// @param receiver Destination address for the constituent assets.\\n    /// @param owner Onwer of the shares.\\n    /// @return assets Amount of asset redeemable by the given number of shares.\\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\\n    function eject(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public returns (uint256 assets, uint256 excessBal, bool isExcessPTs) {\\n        if (maturity == MATURITY_NOT_SET) revert ActivePhaseOnly();\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        yt.collect();\\n\\n        uint256 assetBalPre = asset.balanceOf(address(this));\\n        assets = shares.mulDivDown(assetBalPre, totalSupply);\\n        (excessBal, isExcessPTs) = _exitAndCombine(shares);\\n\\n        _burn(owner, shares); // Burn after percent ownership is determined in _exitAndCombine.\\n\\n        if (isExcessPTs) {\\n            pt.transfer(receiver, excessBal);\\n        } else {\\n            yt.transfer(receiver, excessBal);\\n        }\\n\\n        asset.transfer(receiver, assets = assets + asset.balanceOf(address(this)) - assetBalPre);\\n        emit Ejected(msg.sender, receiver, owner, assets, shares,\\n            isExcessPTs ? excessBal : 0,\\n            isExcessPTs ? 0 : excessBal\\n        );\\n    }\\n\\n    /* ========== GENERAL UTILS ========== */\\n\\n    /// @dev Exit Assets from the Space pool and combine the PTs with YTs we have reserved for the given number of shares.\\n    /// @param shares number of shares to exit and combine with.\\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\\n    function _exitAndCombine(uint256 shares) internal returns (uint256, bool) {\\n        uint256 supply = totalSupply; // Save extra SLOAD.\\n\\n        uint256 lpBal      = shares.mulDivDown(space.balanceOf(address(this)), supply);\\n        uint256 totalPTBal = pt.balanceOf(address(this));\\n        uint256 ptShare    = shares.mulDivDown(totalPTBal, supply);\\n\\n        ERC20[] memory tokens = new ERC20[](2);\\n        tokens[1 - pti] = asset;\\n        tokens[pti    ] = pt;\\n\\n        _exitPool(\\n            poolId,\\n            BalancerVault.ExitPoolRequest({\\n                assets: tokens,\\n                minAmountsOut: new uint256[](2),\\n                userData: abi.encode(lpBal),\\n                toInternalBalance: false\\n            })\\n        );\\n\\n        ptShare += pt.balanceOf(address(this)) - totalPTBal;\\n        uint256 ytBal = shares.mulDivDown(yt.balanceOf(address(this)), supply);\\n        unchecked {\\n            // Safety: an inequality check is done before subtraction.\\n            if (ptShare > ytBal) {\\n                divider.combine(address(adapter), maturity, ytBal);\\n                return (ptShare - ytBal, true);\\n            } else { // Set excess PTs to false if the balances are exactly equal.\\n                divider.combine(address(adapter), maturity, ptShare);\\n                return (ytBal - ptShare, false);\\n            }\\n        }\\n    }\\n\\n    /// @notice Transfer any token not included in the set {asset,yt,pt,space} to the rewards recipient.\\n    /// @param coin address of the coin to transfer out.\\n    function claimRewards(ERC20 coin) external nonReentrant {\\n        require(coin != asset);\\n        if (maturity != MATURITY_NOT_SET) {\\n            require(coin != ERC20(address(yt)) && coin != pt && coin != ERC20(address(space)));\\n        }\\n        coin.safeTransfer(rewardRecipient, coin.balanceOf(address(this)));\\n    }\\n\\n    /* ========== BALANCER UTILS ========== */\\n\\n    function _joinPool(bytes32 _poolId, BalancerVault.JoinPoolRequest memory request) internal {\\n        balancerVault.joinPool(_poolId, address(this), address(this), request);\\n    }\\n\\n    function _exitPool(bytes32 _poolId, BalancerVault.ExitPoolRequest memory request) internal {\\n        balancerVault.exitPool(_poolId, address(this), payable(address(this)), request);\\n    }\\n\\n    function _swap(BalancerVault.SingleSwap memory request) internal {\\n        BalancerVault.FundManagement memory funds = BalancerVault.FundManagement({\\n            sender: address(this),\\n            fromInternalBalance: false,\\n            recipient: payable(address(this)),\\n            toInternalBalance: false\\n        });\\n\\n        balancerVault.swap(request, funds, 0, type(uint256).max);\\n    }\\n\\n    /* ========== NUMERICAL UTILS ========== */\\n\\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    /* ========== INTERNAL VIEWS ========== */\\n\\n    /// @dev Calculates the amount of Target needed for issuance such that the PT:Target ratio in\\n    ///      the Space pool will be preserved after issuing and joining issued PTs and remaining Target.\\n    /// @return asset Amount of Target that should be used for issuance.\\n    function _getTargetForIssuance(uint256 ptReserves, uint256 targetReserves, uint256 targetBal, uint256 scale)\\n        internal view returns (uint256)\\n    {\\n        return targetBal.mulWadUp(ptReserves.divWadUp(\\n            scale.mulWadDown(1e18 - ifee).mulWadDown(targetReserves) + ptReserves\\n        ));\\n    }\\n\\n    /// @dev Get PT and Target reserve balances for the current Space pool.\\n    /// @return ptReserves PT reserve amount.\\n    /// @return targetReserves Target reserve amount.\\n    function _getSpaceReserves() internal view returns (uint256, uint256) {\\n        (, uint256[] memory balances, ) = balancerVault.getPoolTokens(poolId);\\n        uint256 _pti = pti;\\n        return (balances[_pti], balances[1 - _pti]);\\n    }\\n\\n    /// @dev DecomposeShares works to break shares into their constituent parts,\\n    ///      and also preview the assets required to mint a given number of shares.\\n    /// @return targetAmount Target the number of shares has a right to.\\n    /// @return ptAmount PTs the number of shares has a right to.\\n    /// @return ytAmount YTs the number of shares has a right to.\\n    /// @return lpAmount Space LP shares the number of shares has a right to.\\n    function _decomposeShares(uint256 ptReserves, uint256 targetReserves, uint256 shares, bool withLoose)\\n        internal view returns (uint256, uint256, uint256, uint256)\\n    {\\n        uint256 supply      = totalSupply;\\n        uint256 totalLPBal  = space.balanceOf(address(this));\\n        uint256 spaceSupply = space.adjustedTotalSupply();\\n\\n        // Shares have a right to a portion of the PTs/asset floating around unencombered in this contract.\\n        return (\\n            shares.mulDivDown(totalLPBal.mulDivUp(targetReserves, spaceSupply) + (withLoose ? asset.balanceOf(address(this)) : 0), supply),\\n            shares.mulDivDown(totalLPBal.mulDivUp(ptReserves, spaceSupply) + (withLoose ? pt.balanceOf(address(this)) : 0), supply),\\n            shares.mulDivDown(yt.balanceOf(address(this)), supply),\\n            shares.mulDivDown(totalLPBal, supply)\\n        );\\n    }\\n\\n    /* ========== SPACE POOL SOLVERS ========== */\\n\\n    /// @notice Determine the maximum number of PTs we can sell into the current space pool without\\n    ///         exceeding the current `maxRate`.\\n    /// @return ptAmount Maximum number of PTs.\\n    function _maxPTSell(uint256 ptReserves, uint256 targetReserves, uint256 spaceSupply) internal view returns (uint256) {\\n        (uint256 eqPTReserves, ) = space.getEQReserves(\\n            maxRate, // Max acceptable implied rate.\\n            maturity,\\n            ptReserves,\\n            targetReserves,\\n            spaceSupply,\\n            space.g2()\\n        );\\n\\n        return ptReserves >= eqPTReserves ? 0 : eqPTReserves - ptReserves; // Edge case: the pool is already above the max rate.\\n    }\\n\\n    /* ========== ADMIN ========== */\\n\\n    /// @notice Set address-based admin params, only callable by the owner.\\n    /// @param what Admin param to update.\\n    /// @param data Address to set the param to.\\n    function setParam(bytes32 what, address data) external {\\n        require(msg.sender == owner);\\n        if (what == \\\"SPACE_FACTORY\\\") spaceFactory = SpaceFactoryLike(data);\\n        else if (what == \\\"PERIPHERY\\\") periphery = PeripheryLike(data);\\n        else if (what == \\\"OWNER\\\") owner = data;\\n        else revert UnrecognizedParam(what);\\n        emit ParamChanged(what, data);\\n    }\\n\\n    /// @notice Set uint-based admin params, only callable by the owner.\\n    /// @param what Admin param to update.\\n    /// @param data Uint to set the param to.\\n    function setParam(bytes32 what, uint256 data) external {\\n        require(msg.sender == owner);\\n        if (what == \\\"MAX_RATE\\\") maxRate = data;\\n        else if (what == \\\"TARGET_DURATION\\\") targetDuration = data;\\n        else if (what == \\\"COOLDOWN\\\") {\\n            require(lastSettle == 0 || maturity != MATURITY_NOT_SET); // Can't update cooldown during cooldown period.\\n            cooldown = data;\\n        }\\n        else revert UnrecognizedParam(what);\\n        emit ParamChanged(what, data);\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event ParamChanged(bytes32 what, address newData);\\n    event ParamChanged(bytes32 what, uint256 newData);\\n\\n    event Rolled(uint256 nextMaturity, uint256 initScale, address space, address roller);\\n    event Ejected(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares,\\n        uint256 pts,\\n        uint256 yts\\n    );\\n}\\n\\ncontract RollerUtils {\\n    using FixedPointMathLib for uint256;\\n\\n    uint256 internal constant SECONDS_PER_YEAR = 31536000;\\n    uint256 internal constant ONE = 1e18;\\n\\n    address internal immutable divider;\\n\\n    constructor(address _divider) { divider = _divider; }\\n\\n    /// @notice Calculate a maturity timestamp around x months in the future on exactly the top of the month.\\n    /// @param monthsForward Number of months in to advance forward.\\n    /// @return timestamp The timestamp around the number of months forward given, exactly at 00:00 UTC on the top of the month.\\n    function getFutureMaturity(uint256 monthsForward) public view returns (uint256) {\\n        (uint256 year, uint256 month, ) = DateTime.timestampToDate(DateTime.addMonths(block.timestamp, monthsForward));\\n        return DateTime.timestampFromDateTime(year, month, 1 /* top of the month */, 0, 0, 0);\\n    }\\n\\n    /// @notice Calculate a maturity timestamp around x months in the future on exactly the top of the month.\\n    /// @param periphery Currently active Sense Periphery contract.\\n    /// @param adapter Adapter associated with the Series who's Space data this function is fetching.\\n    /// @param maturity Maturity associated with the Series who's Space data this function is fetching.\\n    /// @return space Space pool object associated with the given adapter and maturity.\\n    /// @return poolId Balancer pool ID associated with the Space pool.\\n    /// @return pti Index of the PT token in the Space pool.\\n    /// @return scale Current adapter scale value.\\n    function getSpaceData(PeripheryLike periphery, OwnedAdapterLike adapter, uint256 maturity)\\n        public returns (Space, bytes32, uint256, uint256)\\n    {\\n        Space _space = periphery.spaceFactory().pools(address(adapter), maturity);\\n        return (_space, _space.getPoolId(), _space.pti(), adapter.scale());\\n    }\\n\\n    /// @notice Calculate the APY implied by the change in scale over the Series term (from issuance to maturity), and stretch it to the Space pools' TS period.\\n    /// @ param fallbackTargetedRate Optional Target rate to fallback on if nothing can be computed.\\n    /// @param adapter Adapter associated with the matured Series to analyze.\\n    /// @param prevMaturity Maturity for the maturied Series to analyze.\\n    /// @param space Maturity associated with the Series who's Space data this function is fetching.\\n    /// @return stretchedRate Rate implied by the previous Series stretched to the Space pool's timestretch period.\\n    function getNewTargetedRate(uint256 /* fallbackTargetedRate */, address adapter, uint256 prevMaturity, Space space) public returns (uint256) {\\n        (, uint48 prevIssuance, , , , , uint256 iscale, uint256 mscale, ) = DividerLike(divider).series(adapter, prevMaturity);\\n\\n        require(mscale != 0);\\n\\n        if (mscale <= iscale) return 0;\\n\\n        // Calculate the rate implied via the growth in scale over the previous Series term.\\n        uint256 rate = (_powWad(\\n            (mscale - iscale).divWadDown(iscale) + ONE, ONE.divWadDown((prevMaturity - prevIssuance) * ONE)\\n        ) - ONE).mulWadDown(SECONDS_PER_YEAR * ONE);\\n\\n        // Stretch the targeted rate to match the Space pool's timeshift period.\\n        // e.g. if the timestretch is 1/12 years in seconds, then the rate will be transformed from a yearly rate to a 12-year rate.\\n        return _powWad(rate + ONE, ONE.divWadDown(space.ts().mulWadDown(SECONDS_PER_YEAR * ONE))) - ONE;\\n    }\\n\\n    /// @dev Safe wad pow function for uint256s.\\n    function _powWad(uint256 x, uint256 y) internal pure returns (uint256) {\\n        require(x < 1 << 255);\\n        require(y < 1 << 255);\\n\\n        return uint256(FixedPointMathLib.powWad(int256(x), int256(y))); // Assumption: x cannot be negative so this result will never be.\\n    }\\n}\",\"keccak256\":\"0x4ff0f6baf6cab5cbacdfd1bb331699ce4c2f0a14ee1c819725e00114988dca44\",\"license\":\"AGPL-3.0-only\"},\"lib/auto-roller/src/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nlibrary SafeCast {\\n    function safeCastTo216(uint256 x) internal pure returns (uint216 y) {\\n        require(x < 1 << 216);\\n\\n        y = uint216(x);\\n    }\\n\\n    function safeCastToInt(uint256 x) internal pure returns (int256 y) {\\n        require(x < 1 << 255);\\n\\n        y = int256(x);\\n    }\\n\\n    function safeCastToUint(int256 x) internal pure returns (uint256 y) {\\n        require(x >= 0);\\n\\n        y = uint256(x);\\n    }\\n}\",\"keccak256\":\"0xdbcb6fd4bd8a7328984893bc6c322bf7918dadb5803cf659603644c2b098939a\",\"license\":\"AGPL-3.0-only\"},\"lib/auto-roller/src/external/DateTime.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\n/// @author Taken from: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n\\n// ----------------------------------------------------------------------------\\n// DateTime Library v2.0\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n\\nlibrary DateTime {\\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 constant SECONDS_PER_MINUTE = 60;\\n    int256 constant OFFSET19700101 = 2440588;\\n\\n    uint256 constant DOW_MON = 1;\\n    uint256 constant DOW_TUE = 2;\\n    uint256 constant DOW_WED = 3;\\n    uint256 constant DOW_THU = 4;\\n    uint256 constant DOW_FRI = 5;\\n    uint256 constant DOW_SAT = 6;\\n    uint256 constant DOW_SUN = 7;\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // days = day\\n    //      - 32075\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n    //      - offset\\n    // ------------------------------------------------------------------------\\n    function _daysFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (uint256 _days) {\\n        require(year >= 1970);\\n        int256 _year = int256(year);\\n        int256 _month = int256(month);\\n        int256 _day = int256(day);\\n\\n        int256 __days = _day -\\n            32075 +\\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n            4 +\\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n            12 -\\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n            4 -\\n            OFFSET19700101;\\n\\n        _days = uint256(__days);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n\\n    function timestampFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (uint256 timestamp) {\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\n    }\\n\\n    function timestampFromDateTime(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (uint256 timestamp) {\\n        timestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            hour *\\n            SECONDS_PER_HOUR +\\n            minute *\\n            SECONDS_PER_MINUTE +\\n            second;\\n    }\\n\\n    function timestampToDate(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function timestampToDateTime(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day,\\n            uint256 hour,\\n            uint256 minute,\\n            uint256 second\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint256 secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n        secs = secs % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n        second = secs % SECONDS_PER_MINUTE;\\n    }\\n\\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\n    }\\n\\n    function _getDaysInMonth(uint256 year, uint256 month) internal pure returns (uint256 daysInMonth) {\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\n            daysInMonth = 31;\\n        } else if (month != 2) {\\n            daysInMonth = 30;\\n        } else {\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\n        }\\n    }\\n\\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function addMonths(uint256 timestamp, uint256 _months) internal pure returns (uint256 newTimestamp) {\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        month += _months;\\n        year += (month - 1) / 12;\\n        month = ((month - 1) % 12) + 1;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp + _seconds;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function subSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp - _seconds;\\n        require(newTimestamp <= timestamp);\\n    }\\n}\\n\",\"keccak256\":\"0x13cd037597eb601de79d6ef168ed1e5a736f7f92b3bb405703a43b49005c70ab\",\"license\":\"AGPL-3.0-only\"},\"lib/auto-roller/src/interfaces/BalancerVault.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\n\\ninterface BalancerVault {\\n    struct JoinPoolRequest {\\n        ERC20[] assets;\\n        uint256[] maxAmountsIn;\\n        bytes userData;\\n        bool fromInternalBalance;\\n    }\\n    struct ExitPoolRequest {\\n        ERC20[] assets;\\n        uint256[] minAmountsOut;\\n        bytes userData;\\n        bool toInternalBalance;\\n    }\\n    enum SwapKind {\\n        GIVEN_IN,\\n        GIVEN_OUT\\n    }\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        address assetIn;\\n        address assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        returns (\\n            ERC20[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 maxBlockNumber\\n        );\\n\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    function joinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        JoinPoolRequest memory request\\n    ) external payable;\\n\\n    function exitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address payable recipient,\\n        ExitPoolRequest memory request\\n    ) external;\\n\\n    function getProtocolFeesCollector() external returns (address);\\n    function getAuthorizer() external returns (address);\\n}\",\"keccak256\":\"0x7ad26765e03b7542cc034a70e20dd81f13b4a5c432cea89849d9231c45f78cd7\",\"license\":\"AGPL-3.0-only\"},\"lib/auto-roller/src/interfaces/Space.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\n\\nimport { BalancerVault } from \\\"./BalancerVault.sol\\\";\\n\\ninterface Space {\\n    function getPoolId() external view returns (bytes32);\\n    function totalSupply() external view returns (uint256);\\n    function pti() external view returns (uint256);\\n    function ts() external view returns (uint256);\\n    function g2() external view returns (uint256);\\n    \\n    struct SwapRequest {\\n        BalancerVault.SwapKind kind;\\n        ERC20 tokenIn;\\n        ERC20 tokenOut;\\n        uint256 amount;\\n        // Misc data\\n        bytes32 poolId;\\n        uint256 lastChangeBlock;\\n        address from;\\n        address to;\\n        bytes userData;\\n    }\\n\\n    function onSwap(\\n        SwapRequest memory swapRequest,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) \\n    external \\n    view // This is a lie. But it indeed will only mutate storage if called by the Balancer Vault, so it's true for our purposes here.\\n    returns (uint256);\\n\\n    function balanceOf(address user) external view returns (uint256 amount);\\n    function getPriceFromImpliedRate(uint256 impliedRate) external view returns (uint256 pTPriceInTarget);\\n    function adjustedTotalSupply() external view returns (uint256 supply);\\n    \\n    function getEQReserves(\\n        uint256 stretchedRate,\\n        uint256 maturity,\\n        uint256 ptReserves,\\n        uint256 targetReserves,\\n        uint256 totalSupply,\\n        uint256 initScale\\n    ) external view returns (\\n        uint256 eqPTReserves,\\n        uint256 eqTargetReserves\\n    );\\n\\n    function onSwapPreview(\\n        bool ptIn,\\n        bool givenIn,\\n        uint256 amountDelta,\\n        uint256 reservesTokenIn,\\n        uint256 reservesTokenOut,\\n        uint256 totalSupply,\\n        uint256 scale\\n    ) external view returns (uint256);\\n}\",\"keccak256\":\"0xaeac43e1355662d9b625ae62df444a293ef9391837e0fcc07c6ac9ffd59f8085\",\"license\":\"AGPL-3.0-only\"},\"lib/auto-roller/src/test/utils/MockOwnedAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\nimport { MockERC20 } from \\\"solmate/src/test/utils/mocks/MockERC20.sol\\\";\\n\\nimport { Trust } from \\\"@sense-finance/v1-utils/src/Trust.sol\\\";\\nimport { BaseAdapter } from \\\"@sense-finance/v1-core/src/adapters/abstract/BaseAdapter.sol\\\";\\n\\nimport { AutoRoller, SpaceFactoryLike } from \\\"../../AutoRoller.sol\\\";\\n\\ninterface Opener {\\n    function onSponsorWindowOpened(address, uint256) external;\\n}\\n\\nabstract contract OwnableAdapter is BaseAdapter {\\n    function openSponsorWindow() external virtual {\\n        Opener(msg.sender).onSponsorWindowOpened(address(0), 0);\\n    }\\n}\\n\\ncontract MockOwnableAdapter is OwnableAdapter, Trust {\\n    uint256 public override scale = 1.1e18;\\n    uint256 internal open = 1;\\n\\n    constructor(\\n        address _divider,\\n        address _target,\\n        address _underlying,\\n        AdapterParams memory _adapterParams\\n    ) BaseAdapter(_divider, _target, _underlying, 0.0012e18, _adapterParams) Trust(msg.sender) { }\\n\\n    function scaleStored() external view virtual override returns (uint256 _scale) {\\n        _scale = scale;\\n    }\\n\\n    function wrapUnderlying(uint256 uBal) external virtual override returns (uint256 amountOut) {\\n        MockERC20 target = MockERC20(target);\\n        MockERC20 underlying = MockERC20(underlying);\\n\\n        uint256 tDecimals = target.decimals();\\n        uint256 uDecimals = underlying.decimals();\\n\\n        underlying.transferFrom(msg.sender, address(this), uBal);\\n        if (tDecimals == uDecimals) {\\n            amountOut = uBal * 1e18 / scale;\\n        } else {\\n            amountOut = uDecimals < tDecimals ?\\n                uBal * 1e18 / scale * (tDecimals - uDecimals) ** 10 :\\n                uBal * 1e18 / scale / (uDecimals - tDecimals) ** 10;\\n        }\\n\\n        target.mint(msg.sender, amountOut);\\n    }\\n\\n    function unwrapTarget(uint256 tBal) external virtual override returns (uint256 amountOut) {\\n        MockERC20 target = MockERC20(target);\\n        MockERC20 underlying = MockERC20(underlying);\\n\\n        uint256 tDecimals = target.decimals();\\n        uint256 uDecimals = underlying.decimals();\\n\\n        target.transferFrom(msg.sender, address(this), tBal);\\n        if (tDecimals == uDecimals) {\\n            amountOut = tBal * scale / 1e18;\\n        } else {\\n            amountOut = uDecimals < tDecimals ?\\n                tBal * scale / 1e18 / (tDecimals - uDecimals) ** 10 :\\n                tBal * scale / 1e18 * (uDecimals - tDecimals) ** 10;\\n        }\\n            \\n        underlying.mint(msg.sender, amountOut);\\n    }\\n\\n    function getUnderlyingPrice() external view virtual override returns (uint256) {\\n        return 1e18;\\n    }\\n\\n    function setScale(uint256 _scale) external {\\n        scale = _scale;\\n    }\\n\\n    function openSponsorWindow() external override requiresTrust {\\n        open = 2;\\n        Opener(msg.sender).onSponsorWindowOpened(adapterParams.stake, adapterParams.stakeSize);\\n        open = 1;\\n    }\\n\\n    function getMaturityBounds() external view override returns (uint256, uint256) {\\n        return open == 2 ? (0, type(uint64).max / 2) : (0, 0);\\n    }\\n}\",\"keccak256\":\"0x9cbbffbed761a48e2d9fa31fbe50df1289f19edbcc06be8a7e940597b5f8f0f3\",\"license\":\"UNLICENSED\"},\"solmate/src/mixins/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\",\"keccak256\":\"0xa0e0c28a727524fa94e7e6c1f4c793a6bd1e6d1bc652b7b02b343ebaf4cd774b\",\"license\":\"MIT\"},\"solmate/src/test/utils/mocks/MockERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../../../tokens/ERC20.sol\\\";\\n\\ncontract MockERC20 is ERC20 {\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) ERC20(_name, _symbol, _decimals) {}\\n\\n    function mint(address to, uint256 value) public virtual {\\n        _mint(to, value);\\n    }\\n\\n    function burn(address from, uint256 value) public virtual {\\n        _burn(from, value);\\n    }\\n}\\n\",\"keccak256\":\"0x8c182806df355c780d3e0b5e7975b32e312e961f0d51f30ba46732bd7b7ba23d\",\"license\":\"MIT\"},\"solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x43aa1509bb753f053143530705d9c4eee415691d26a4779769bf028a74e6ac69\",\"license\":\"MIT\"},\"solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\\n    }\\n\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return 0;\\n\\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n            if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5**18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            require(x > 0, \\\"UNDEFINED\\\");\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            int256 k = int256(log2(uint256(x))) - 96;\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // z will equal 0 if y is 0, unlike in Solidity where it will revert.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // z will equal 0 if y is 0, unlike in Solidity where it will revert.\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Will return 0 instead of reverting if y is zero.\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // Add 1 to x * y if x % y > 0.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0bf1d4f3999a4471e0fded0a2f67e7fe328e2a27385348571b1fc0a8d9c9f62e\",\"license\":\"MIT\"},\"solmate/src/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\",\"keccak256\":\"0xa0e50a0f232da7f289430601ba927c315266b20ec739761430b0fde926fefe55\",\"license\":\"MIT\"},\"solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, from) // Append the \\\"from\\\" argument.\\n            mstore(36, to) // Append the \\\"to\\\" argument.\\n            mstore(68, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because that's the total length of our calldata (4 + 32 * 3)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 100, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x5f2e1158c68c1f3d15b80e8a7dd92b6849f873066969562ad33c0abb80e536ff\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x610100604052670f43fc2c04ee00006009556001600a553480156200002357600080fd5b5060405162001e9d38038062001e9d833981016040819052620000469162000423565b6001600160a01b03808516608090815281851660a081815283861660c090815266044364c5bb000060e08181528751600080549189166001600160a01b031992831617815560208a01516001805491909a1692169190911790975560408089015160025560608901516003559588015160049081559388015160058054948a0151928a015161ffff16600160701b0261ffff60701b1965ffffffffffff90941668010000000000000000026001600160701b03199096166001600160401b039093169290921794909417919091161790915583516306fdde0360e01b8152935133958a958a958a958a9491936306fdde0393808301939192908290030181865afa15801562000159573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526200018391908101906200054b565b60405160200162000195919062000603565b60405160208183030381529060405260069081620001b49190620006c0565b50836001600160a01b03166395d89b416040518163ffffffff1660e01b8152600401600060405180830381865afa158015620001f4573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526200021e91908101906200054b565b6040516020016200023091906200078c565b604051602081830303815290604052600790816200024f9190620006c0565b5062000279608051600019866001600160a01b03166200031260201b62000fb3179092919060201c565b620002a660805160001983602001516001600160a01b03166200031260201b62000fb3179092919060201c565b505050506001600160a01b038216600081815260086020908152604091829020805460ff1916600190811790915591519182529192507fe95aec380cae16330d146d5499ef7db6f3657e477104a733e771bc09e500d986910160405180910390a25050505050620007ba565b600060405163095ea7b360e01b6000528360045282602452602060006044600080895af13d15601f3d1160016000511416171691506000606052806040525080620003945760405162461bcd60e51b815260206004820152600e60248201526d1054141493d59157d1905253115160921b604482015260640160405180910390fd5b50505050565b80516001600160a01b0381168114620003b257600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60405161010081016001600160401b0381118282101715620003f357620003f3620003b7565b60405290565b805165ffffffffffff81168114620003b257600080fd5b805161ffff81168114620003b257600080fd5b6000806000808486036101608112156200043c57600080fd5b62000447866200039a565b945062000457602087016200039a565b935062000467604087016200039a565b925061010080605f19830112156200047e57600080fd5b62000488620003cd565b915062000498606088016200039a565b8252620004a8608088016200039a565b602083015260a0870151604083015260c0870151606083015260e087015160808301528601516001600160401b0381168114620004e457600080fd5b60a0820152620004f86101208701620003f9565b60c08201526200050c610140870162000410565b60e0820152939692955090935050565b60005b83811015620005395781810151838201526020016200051f565b83811115620003945750506000910152565b6000602082840312156200055e57600080fd5b81516001600160401b03808211156200057657600080fd5b818401915084601f8301126200058b57600080fd5b815181811115620005a057620005a0620003b7565b604051601f8201601f19908116603f01168101908382118183101715620005cb57620005cb620003b7565b81604052828152876020848701011115620005e557600080fd5b620005f88360208301602088016200051c565b979650505050505050565b60008251620006178184602087016200051c565b671020b230b83a32b960c11b920191825250600801919050565b600181811c908216806200064657607f821691505b6020821081036200066757634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620006bb57600081815260208120601f850160051c81016020861015620006965750805b601f850160051c820191505b81811015620006b757828155600101620006a2565b5050505b505050565b81516001600160401b03811115620006dc57620006dc620003b7565b620006f481620006ed845462000631565b846200066d565b602080601f8311600181146200072c5760008415620007135750858301515b600019600386901b1c1916600185901b178555620006b7565b600085815260208120601f198616915b828110156200075d578886015182559484019460019091019084016200073c565b50858210156200077c5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60008251620007a08184602087016200051c565b6716b0b230b83a32b960c11b920191825250600801919050565b60805160a05160c05160e0516116636200083a60003960006104b401526000818161040c015281816107700152610a2c0152600081816102dd0152818161050e0152818161074b01528181610a0701528181610d4f01528181610d9f01528181610e610152610f5a0152600081816103330152610c9b01526116636000f3fe608060405234801561001057600080fd5b50600436106101b95760003560e01c80635cffe9de116100f957806396d6487911610097578063c39a3b2911610071578063c39a3b29146104f7578063d4b8399214610509578063d9d98ce414610530578063f51e181a1461054357600080fd5b806396d6487914610479578063b484972a1461049c578063b8c15a9f146104af57600080fd5b80636f307dc3116100d35780636f307dc3146104075780636fd5ae151461042e5780638237e5381461044a57806395d89b411461047157600080fd5b80635cffe9de146103b4578063613255ab146103d757806364c56e3c146103ea57600080fd5b8063295a5212116101665780633edc3519116101405780633edc35191461036d578063468f02d2146103805780634aae9fed1461038e57806351c39ea1146103a157600080fd5b8063295a5212146103135780632c5786b814610326578063378efa371461032e57600080fd5b806314282f581161019757806314282f58146102a357806322677849146102b757806327b327d0146102c957600080fd5b806306fdde03146101be578063083118d5146101dc5780631393916a1461028e575b600080fd5b6101c661054c565b6040516101d39190611162565b60405180910390f35b600054600154600254600354600454600554610232956001600160a01b0390811695169392919067ffffffffffffffff81169068010000000000000000810465ffffffffffff1690600160701b900461ffff1688565b604080516001600160a01b03998a168152989097166020890152958701949094526060860192909252608085015267ffffffffffffffff1660a084015265ffffffffffff1660c083015261ffff1660e0820152610100016101d3565b6102a161029c3660046111dd565b6105da565b005b6102a16102b1366004611216565b50505050565b6009545b6040519081526020016101d3565b600154600254604080516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116825290931660208401528201526060016101d3565b600554600160701b900461ffff166102bb565b6102a1610689565b6103557f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016101d3565b6102a161037b366004611248565b600955565b670de0b6b3a76400006102bb565b6102bb61039c366004611248565b610746565b6102bb6103af366004611248565b610a02565b6103c76103c2366004611261565b610c8d565b60405190151581526020016101d3565b6102bb6103e5366004611300565b610e96565b6103f2610f07565b604080519283526020830191909152016101d3565b6103557f000000000000000000000000000000000000000000000000000000000000000081565b60055468010000000000000000900465ffffffffffff166102bb565b6102bb7f439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd981565b6101c6610f49565b6103c7610487366004611300565b60086020526000908152604090205460ff1681565b6102a16104aa366004611324565b505050565b6104d67f000000000000000000000000000000000000000000000000000000000000000081565b6040516fffffffffffffffffffffffffffffffff90911681526020016101d3565b60055467ffffffffffffffff166102bb565b6103557f000000000000000000000000000000000000000000000000000000000000000081565b6102bb61053e366004611366565b610f56565b6102bb60095481565b6006805461055990611392565b80601f016020809104026020016040519081016040528092919081815260200182805461058590611392565b80156105d25780601f106105a7576101008083540402835291602001916105d2565b820191906000526020600020905b8154815290600101906020018083116105b557829003601f168201915b505050505081565b3360009081526008602052604090205460ff1661062a5760405162461bcd60e51b8152602060048201526009602482015268155395149554d5115160ba1b60448201526064015b60405180910390fd5b6001600160a01b038216600081815260086020908152604091829020805460ff191685151590811790915591519182527fe95aec380cae16330d146d5499ef7db6f3657e477104a733e771bc09e500d986910160405180910390a25050565b3360009081526008602052604090205460ff166106d45760405162461bcd60e51b8152602060048201526009602482015268155395149554d5115160ba1b6044820152606401610621565b6002600a819055600154905460405163dfd4718f60e01b81526001600160a01b0390921660048301526024820152339063dfd4718f90604401600060405180830381600087803b15801561072757600080fd5b505af115801561073b573d6000803e3d6000fd5b50506001600a555050565b6000807f0000000000000000000000000000000000000000000000000000000000000000905060007f000000000000000000000000000000000000000000000000000000000000000090506000826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107f591906113cc565b60ff1690506000826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561083a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061085e91906113cc565b6040516323b872dd60e01b81523360048201523060248201526044810188905260ff9190911691506001600160a01b038416906323b872dd906064016020604051808303816000875af11580156108b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108dd91906113ef565b5080820361090b576009546108fa87670de0b6b3a7640000611422565b6109049190611457565b9450610998565b81811061095657600a61091e838361146b565b6109289190611566565b60095461093d88670de0b6b3a7640000611422565b6109479190611457565b6109519190611457565b610995565b600a610962828461146b565b61096c9190611566565b60095461098188670de0b6b3a7640000611422565b61098b9190611457565b6109959190611422565b94505b6040516340c10f1960e01b8152336004820152602481018690526001600160a01b038516906340c10f19906044015b600060405180830381600087803b1580156109e157600080fd5b505af11580156109f5573d6000803e3d6000fd5b5050505050505050919050565b6000807f0000000000000000000000000000000000000000000000000000000000000000905060007f000000000000000000000000000000000000000000000000000000000000000090506000826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ab191906113cc565b60ff1690506000826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610af6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1a91906113cc565b6040516323b872dd60e01b81523360048201523060248201526044810188905260ff9190911691506001600160a01b038516906323b872dd906064016020604051808303816000875af1158015610b75573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b9991906113ef565b50808203610bc957670de0b6b3a764000060095487610bb89190611422565b610bc29190611457565b9450610c5a565b818110610c1657600a610bdc838361146b565b610be69190611566565b670de0b6b3a764000060095488610bfd9190611422565b610c079190611457565b610c119190611422565b610c57565b600a610c22828461146b565b610c2c9190611566565b670de0b6b3a764000060095488610c439190611422565b610c4d9190611457565b610c579190611457565b94505b6040516340c10f1960e01b8152336004820152602481018690526001600160a01b038416906340c10f19906044016109c7565b6000336001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166377aace1a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cf7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d1b9190611575565b6001600160a01b031614610d425760405163fb02114960e01b815260040160405180910390fd5b610d766001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016878661103f565b6040516323e30c8b60e01b81526000906001600160a01b038816906323e30c8b90610dcf9033907f0000000000000000000000000000000000000000000000000000000000000000908a9087908b908b90600401611592565b6020604051808303816000875af1158015610dee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e1291906115ed565b90507f439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd98114610e545760405163081f7c8760e21b815260040160405180910390fd5b610e896001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168830886110cb565b5060019695505050505050565b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa158015610edd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f0191906115ed565b92915050565b600080600a54600214610f1c57600080610f31565b6000610f31600267ffffffffffffffff611606565b60ff9091169367ffffffffffffffff90911692509050565b6007805461055990611392565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316836001600160a01b031614610faa57604051633dd1b30560e01b815260040160405180910390fd5b50600092915050565b600060405163095ea7b360e01b6000528360045282602452602060006044600080895af13d15601f3d11600160005114161716915060006060528060405250806102b15760405162461bcd60e51b815260206004820152600e60248201527f415050524f56455f4641494c45440000000000000000000000000000000000006044820152606401610621565b600060405163a9059cbb60e01b6000528360045282602452602060006044600080895af13d15601f3d11600160005114161716915060006060528060405250806102b15760405162461bcd60e51b815260206004820152600f60248201527f5452414e534645525f4641494c454400000000000000000000000000000000006044820152606401610621565b60006040516323b872dd60e01b6000528460045283602452826044526020600060646000808a5af13d15601f3d116001600051141617169150600060605280604052508061115b5760405162461bcd60e51b815260206004820152601460248201527f5452414e534645525f46524f4d5f4641494c45440000000000000000000000006044820152606401610621565b5050505050565b600060208083528351808285015260005b8181101561118f57858101830151858201604001528201611173565b818111156111a1576000604083870101525b50601f01601f1916929092016040019392505050565b6001600160a01b03811681146111cc57600080fd5b50565b80151581146111cc57600080fd5b600080604083850312156111f057600080fd5b82356111fb816111b7565b9150602083013561120b816111cf565b809150509250929050565b6000806000806080858703121561122c57600080fd5b5050823594602084013594506040840135936060013592509050565b60006020828403121561125a57600080fd5b5035919050565b60008060008060006080868803121561127957600080fd5b8535611284816111b7565b94506020860135611294816111b7565b935060408601359250606086013567ffffffffffffffff808211156112b857600080fd5b818801915088601f8301126112cc57600080fd5b8135818111156112db57600080fd5b8960208285010111156112ed57600080fd5b9699959850939650602001949392505050565b60006020828403121561131257600080fd5b813561131d816111b7565b9392505050565b60008060006060848603121561133957600080fd5b8335611344816111b7565b925060208401359150604084013561135b816111cf565b809150509250925092565b6000806040838503121561137957600080fd5b8235611384816111b7565b946020939093013593505050565b600181811c908216806113a657607f821691505b6020821081036113c657634e487b7160e01b600052602260045260246000fd5b50919050565b6000602082840312156113de57600080fd5b815160ff8116811461131d57600080fd5b60006020828403121561140157600080fd5b815161131d816111cf565b634e487b7160e01b600052601160045260246000fd5b600081600019048311821515161561143c5761143c61140c565b500290565b634e487b7160e01b600052601260045260246000fd5b60008261146657611466611441565b500490565b60008282101561147d5761147d61140c565b500390565b600181815b808511156114bd5781600019048211156114a3576114a361140c565b808516156114b057918102915b93841c9390800290611487565b509250929050565b6000826114d457506001610f01565b816114e157506000610f01565b81600181146114f757600281146115015761151d565b6001915050610f01565b60ff8411156115125761151261140c565b50506001821b610f01565b5060208310610133831016604e8410600b8410161715611540575081810a610f01565b61154a8383611482565b806000190482111561155e5761155e61140c565b029392505050565b600061131d60ff8416836114c5565b60006020828403121561158757600080fd5b815161131d816111b7565b60006001600160a01b03808916835280881660208401525085604083015284606083015260a060808301528260a0830152828460c0840137600060c0848401015260c0601f19601f8501168301019050979650505050505050565b6000602082840312156115ff57600080fd5b5051919050565b600067ffffffffffffffff8084168061162157611621611441565b9216919091049291505056fea26469706673582212209e1e81e142d955756d330f40e497a143dad7a97b9babaf26193c88108973e81b64736f6c634300080f0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101b95760003560e01c80635cffe9de116100f957806396d6487911610097578063c39a3b2911610071578063c39a3b29146104f7578063d4b8399214610509578063d9d98ce414610530578063f51e181a1461054357600080fd5b806396d6487914610479578063b484972a1461049c578063b8c15a9f146104af57600080fd5b80636f307dc3116100d35780636f307dc3146104075780636fd5ae151461042e5780638237e5381461044a57806395d89b411461047157600080fd5b80635cffe9de146103b4578063613255ab146103d757806364c56e3c146103ea57600080fd5b8063295a5212116101665780633edc3519116101405780633edc35191461036d578063468f02d2146103805780634aae9fed1461038e57806351c39ea1146103a157600080fd5b8063295a5212146103135780632c5786b814610326578063378efa371461032e57600080fd5b806314282f581161019757806314282f58146102a357806322677849146102b757806327b327d0146102c957600080fd5b806306fdde03146101be578063083118d5146101dc5780631393916a1461028e575b600080fd5b6101c661054c565b6040516101d39190611162565b60405180910390f35b600054600154600254600354600454600554610232956001600160a01b0390811695169392919067ffffffffffffffff81169068010000000000000000810465ffffffffffff1690600160701b900461ffff1688565b604080516001600160a01b03998a168152989097166020890152958701949094526060860192909252608085015267ffffffffffffffff1660a084015265ffffffffffff1660c083015261ffff1660e0820152610100016101d3565b6102a161029c3660046111dd565b6105da565b005b6102a16102b1366004611216565b50505050565b6009545b6040519081526020016101d3565b600154600254604080516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116825290931660208401528201526060016101d3565b600554600160701b900461ffff166102bb565b6102a1610689565b6103557f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016101d3565b6102a161037b366004611248565b600955565b670de0b6b3a76400006102bb565b6102bb61039c366004611248565b610746565b6102bb6103af366004611248565b610a02565b6103c76103c2366004611261565b610c8d565b60405190151581526020016101d3565b6102bb6103e5366004611300565b610e96565b6103f2610f07565b604080519283526020830191909152016101d3565b6103557f000000000000000000000000000000000000000000000000000000000000000081565b60055468010000000000000000900465ffffffffffff166102bb565b6102bb7f439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd981565b6101c6610f49565b6103c7610487366004611300565b60086020526000908152604090205460ff1681565b6102a16104aa366004611324565b505050565b6104d67f000000000000000000000000000000000000000000000000000000000000000081565b6040516fffffffffffffffffffffffffffffffff90911681526020016101d3565b60055467ffffffffffffffff166102bb565b6103557f000000000000000000000000000000000000000000000000000000000000000081565b6102bb61053e366004611366565b610f56565b6102bb60095481565b6006805461055990611392565b80601f016020809104026020016040519081016040528092919081815260200182805461058590611392565b80156105d25780601f106105a7576101008083540402835291602001916105d2565b820191906000526020600020905b8154815290600101906020018083116105b557829003601f168201915b505050505081565b3360009081526008602052604090205460ff1661062a5760405162461bcd60e51b8152602060048201526009602482015268155395149554d5115160ba1b60448201526064015b60405180910390fd5b6001600160a01b038216600081815260086020908152604091829020805460ff191685151590811790915591519182527fe95aec380cae16330d146d5499ef7db6f3657e477104a733e771bc09e500d986910160405180910390a25050565b3360009081526008602052604090205460ff166106d45760405162461bcd60e51b8152602060048201526009602482015268155395149554d5115160ba1b6044820152606401610621565b6002600a819055600154905460405163dfd4718f60e01b81526001600160a01b0390921660048301526024820152339063dfd4718f90604401600060405180830381600087803b15801561072757600080fd5b505af115801561073b573d6000803e3d6000fd5b50506001600a555050565b6000807f0000000000000000000000000000000000000000000000000000000000000000905060007f000000000000000000000000000000000000000000000000000000000000000090506000826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107f591906113cc565b60ff1690506000826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561083a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061085e91906113cc565b6040516323b872dd60e01b81523360048201523060248201526044810188905260ff9190911691506001600160a01b038416906323b872dd906064016020604051808303816000875af11580156108b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108dd91906113ef565b5080820361090b576009546108fa87670de0b6b3a7640000611422565b6109049190611457565b9450610998565b81811061095657600a61091e838361146b565b6109289190611566565b60095461093d88670de0b6b3a7640000611422565b6109479190611457565b6109519190611457565b610995565b600a610962828461146b565b61096c9190611566565b60095461098188670de0b6b3a7640000611422565b61098b9190611457565b6109959190611422565b94505b6040516340c10f1960e01b8152336004820152602481018690526001600160a01b038516906340c10f19906044015b600060405180830381600087803b1580156109e157600080fd5b505af11580156109f5573d6000803e3d6000fd5b5050505050505050919050565b6000807f0000000000000000000000000000000000000000000000000000000000000000905060007f000000000000000000000000000000000000000000000000000000000000000090506000826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ab191906113cc565b60ff1690506000826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610af6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1a91906113cc565b6040516323b872dd60e01b81523360048201523060248201526044810188905260ff9190911691506001600160a01b038516906323b872dd906064016020604051808303816000875af1158015610b75573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b9991906113ef565b50808203610bc957670de0b6b3a764000060095487610bb89190611422565b610bc29190611457565b9450610c5a565b818110610c1657600a610bdc838361146b565b610be69190611566565b670de0b6b3a764000060095488610bfd9190611422565b610c079190611457565b610c119190611422565b610c57565b600a610c22828461146b565b610c2c9190611566565b670de0b6b3a764000060095488610c439190611422565b610c4d9190611457565b610c579190611457565b94505b6040516340c10f1960e01b8152336004820152602481018690526001600160a01b038416906340c10f19906044016109c7565b6000336001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166377aace1a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cf7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d1b9190611575565b6001600160a01b031614610d425760405163fb02114960e01b815260040160405180910390fd5b610d766001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016878661103f565b6040516323e30c8b60e01b81526000906001600160a01b038816906323e30c8b90610dcf9033907f0000000000000000000000000000000000000000000000000000000000000000908a9087908b908b90600401611592565b6020604051808303816000875af1158015610dee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e1291906115ed565b90507f439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd98114610e545760405163081f7c8760e21b815260040160405180910390fd5b610e896001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168830886110cb565b5060019695505050505050565b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa158015610edd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f0191906115ed565b92915050565b600080600a54600214610f1c57600080610f31565b6000610f31600267ffffffffffffffff611606565b60ff9091169367ffffffffffffffff90911692509050565b6007805461055990611392565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316836001600160a01b031614610faa57604051633dd1b30560e01b815260040160405180910390fd5b50600092915050565b600060405163095ea7b360e01b6000528360045282602452602060006044600080895af13d15601f3d11600160005114161716915060006060528060405250806102b15760405162461bcd60e51b815260206004820152600e60248201527f415050524f56455f4641494c45440000000000000000000000000000000000006044820152606401610621565b600060405163a9059cbb60e01b6000528360045282602452602060006044600080895af13d15601f3d11600160005114161716915060006060528060405250806102b15760405162461bcd60e51b815260206004820152600f60248201527f5452414e534645525f4641494c454400000000000000000000000000000000006044820152606401610621565b60006040516323b872dd60e01b6000528460045283602452826044526020600060646000808a5af13d15601f3d116001600051141617169150600060605280604052508061115b5760405162461bcd60e51b815260206004820152601460248201527f5452414e534645525f46524f4d5f4641494c45440000000000000000000000006044820152606401610621565b5050505050565b600060208083528351808285015260005b8181101561118f57858101830151858201604001528201611173565b818111156111a1576000604083870101525b50601f01601f1916929092016040019392505050565b6001600160a01b03811681146111cc57600080fd5b50565b80151581146111cc57600080fd5b600080604083850312156111f057600080fd5b82356111fb816111b7565b9150602083013561120b816111cf565b809150509250929050565b6000806000806080858703121561122c57600080fd5b5050823594602084013594506040840135936060013592509050565b60006020828403121561125a57600080fd5b5035919050565b60008060008060006080868803121561127957600080fd5b8535611284816111b7565b94506020860135611294816111b7565b935060408601359250606086013567ffffffffffffffff808211156112b857600080fd5b818801915088601f8301126112cc57600080fd5b8135818111156112db57600080fd5b8960208285010111156112ed57600080fd5b9699959850939650602001949392505050565b60006020828403121561131257600080fd5b813561131d816111b7565b9392505050565b60008060006060848603121561133957600080fd5b8335611344816111b7565b925060208401359150604084013561135b816111cf565b809150509250925092565b6000806040838503121561137957600080fd5b8235611384816111b7565b946020939093013593505050565b600181811c908216806113a657607f821691505b6020821081036113c657634e487b7160e01b600052602260045260246000fd5b50919050565b6000602082840312156113de57600080fd5b815160ff8116811461131d57600080fd5b60006020828403121561140157600080fd5b815161131d816111cf565b634e487b7160e01b600052601160045260246000fd5b600081600019048311821515161561143c5761143c61140c565b500290565b634e487b7160e01b600052601260045260246000fd5b60008261146657611466611441565b500490565b60008282101561147d5761147d61140c565b500390565b600181815b808511156114bd5781600019048211156114a3576114a361140c565b808516156114b057918102915b93841c9390800290611487565b509250929050565b6000826114d457506001610f01565b816114e157506000610f01565b81600181146114f757600281146115015761151d565b6001915050610f01565b60ff8411156115125761151261140c565b50506001821b610f01565b5060208310610133831016604e8410600b8410161715611540575081810a610f01565b61154a8383611482565b806000190482111561155e5761155e61140c565b029392505050565b600061131d60ff8416836114c5565b60006020828403121561158757600080fd5b815161131d816111b7565b60006001600160a01b03808916835280881660208401525085604083015284606083015260a060808301528260a0830152828460c0840137600060c0848401015260c0601f19601f8501168301019050979650505050505050565b6000602082840312156115ff57600080fd5b5051919050565b600067ffffffffffffffff8084168061162157611621611441565b9216919091049291505056fea26469706673582212209e1e81e142d955756d330f40e497a143dad7a97b9babaf26193c88108973e81b64736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "flashLoan(address,address,uint256,bytes)": {
        "params": {
          "amount": "The amount of target lent.",
          "data": "(encoded adapter address, maturity and YT amount the use has sent in)",
          "receiver": "The contract receiving target, needs to implement the `onFlashLoan(address user, address adapter, uint256 maturity, uint256 amount)` interface."
        }
      },
      "maxFlashLoan(address)": {
        "details": "The amount of currency available to be lent.",
        "params": {
          "token": "The loan currency."
        },
        "returns": {
          "_0": "The amount of `token` that can be borrowed."
        }
      },
      "scaleStored()": {
        "details": "For situations where you need scale from a view function"
      }
    },
    "stateVariables": {
      "scale": {
        "details": "For some Targets, such as cTokens, this is simply the exchange rate, or `supply cToken / supply underlying`For other Targets, such as AMM LP shares, specialized logic will be requiredThis function _must_ return a WAD number representing the current exchange rate between the Target and the Underlying.",
        "return": "value WAD Scale value",
        "returns": {
          "_0": "value WAD Scale value"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "adapterParams()": {
        "notice": "adapter params"
      },
      "divider()": {
        "notice": "Sense core Divider address"
      },
      "flashLoan(address,address,uint256,bytes)": {
        "notice": "Loan `amount` target to `receiver`, and takes it back after the callback."
      },
      "getUnderlyingPrice()": {
        "notice": "Returns the current price of the underlying in ETH terms"
      },
      "ifee()": {
        "notice": "Issuance fee"
      },
      "notify(address,uint256,bool)": {
        "notice": "Notification whenever the Divider adds or removes Target"
      },
      "onRedeem(uint256,uint256,uint256,uint256)": {
        "notice": "Hook called whenever a user redeems PT"
      },
      "scale()": {
        "notice": "Calculate and return this adapter's Scale value for the current timestamp. To be overriden by child contracts"
      },
      "scaleStored()": {
        "notice": "Cached scale value getter"
      },
      "target()": {
        "notice": "Target token to divide"
      },
      "underlying()": {
        "notice": "Underlying for the Target"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7480,
        "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
        "label": "adapterParams",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(AdapterParams)7505_storage"
      },
      {
        "astId": 7507,
        "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
        "label": "name",
        "offset": 0,
        "slot": "6",
        "type": "t_string_storage"
      },
      {
        "astId": 7509,
        "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
        "label": "symbol",
        "offset": 0,
        "slot": "7",
        "type": "t_string_storage"
      },
      {
        "astId": 21392,
        "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
        "label": "isTrusted",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 27311,
        "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
        "label": "scale",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 27314,
        "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
        "label": "open",
        "offset": 0,
        "slot": "10",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(AdapterParams)7505_storage": {
        "encoding": "inplace",
        "label": "struct BaseAdapter.AdapterParams",
        "members": [
          {
            "astId": 7483,
            "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
            "label": "oracle",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 7486,
            "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
            "label": "stake",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 7489,
            "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
            "label": "stakeSize",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 7492,
            "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
            "label": "minm",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 7495,
            "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
            "label": "maxm",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 7498,
            "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
            "label": "tilt",
            "offset": 0,
            "slot": "5",
            "type": "t_uint64"
          },
          {
            "astId": 7501,
            "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
            "label": "level",
            "offset": 8,
            "slot": "5",
            "type": "t_uint48"
          },
          {
            "astId": 7504,
            "contract": "lib/auto-roller/src/test/utils/MockOwnedAdapter.sol:MockOwnableAdapter",
            "label": "mode",
            "offset": 14,
            "slot": "5",
            "type": "t_uint16"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint48": {
        "encoding": "inplace",
        "label": "uint48",
        "numberOfBytes": "6"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}